we don't have any return type anymore. In the end just simply call readData() function in your onCreate function and pass an instance of the MyCallback interface as an argument like this:
"for collections as return types always return an empty collection instead of a null, unless you need a third state of ""not present"".  Kotlin has helper functions such as emptyList() or emptySet() to create these empty values."
"when using methods which return a nullable value for which you have a default or alternative, use the Elvis operator to provide a default value.  In the case of a Map use the getOrElse() which allows a default value to be generated instead of Map method get() which returns a nullable value.  Same for getOrPut()"
"look at functions that can help already, such as for String?.isNullOrEmpty() and String?.isNullOrBlank() which can operate on a nullable value safely and do what you expect.  In fact, you can add your own extensions to fill in any gaps in the standard library."
"helper functions like filterNotNull() which remove nulls from collections, or listOfNotNull() for returning a zero or single item list from a possibly null value."
"To get a reference to a Firebase Realtime Database other than the (default) ""us-central1"", for instance ""europe-west1"", you must pass the database URL to the getInstance() method."
"As an alternative solution, you can download an up-to-date google-services.json from the Firebase Console and add it to your app. If the correct URL of the location is in there, the SDK will read it from there when you call FirebaseDatabase.getInstance() without passing any arguments."
Edit: I understand why this happens that wasn't my point. My point is that it at least needs to give a warning or call the notifyDataSetChanged() function. Because apparently I am calling the submitList(...) function for a reason. I am pretty sure people are trying to figure out what went wrong for hours until they figure out the submitList() ignores silently the call.
"For our earlier example, val intToLong: Int.() -> Long = { toLong() } , it effectively results in the block of code being evaluated in a different context, as if it was placed in a function inside Int. Here's a different example using handcrafted types that showcases this better:"
"Only the parameterless constructor is deprecated, it is now preferred that you specify the Looper in the constructor via the Looper.getMainLooper() method."
"We are not able to get correct size because we needed to invoke dimensionScope.content() before measuring but in some cases you might be able to get Constraints, size or parameters from parent or your calculation. When that's the case you can pass you Size. I made an image that passes drawing area based on ContentScale as you can see here using scope."
"The truth is: data classes do not play too well with inheritance. We are considering prohibiting or severely restricting inheritance of data classes. For example, it's known that there's no way to implement equals() correctly in a hierarchy on non-abstract classes. "
"The reason is that JSON_ARRAYAGG() (like most aggregate functions) produces NULL for empty sets, instead of a more ""reasonable"" empty []. Clearly, you never want this behaviour. So, you could use COALESCE, instead, see also this question:"
"If you hold a reference to an instance of Lazy, isInitialized() allows you to check whether it has already been initialized (and you can obtain such instance with reflection from a delegated property). To check whether a lateinit property has been initialized, you can use property::isInitialized since Kotlin 1.2."
"Also, there's another way not mentioned in the question: Delegates.notNull(), which is suitable for deferred initialization of non-null properties, including those of Java primitive types."
The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method:
"If you need more control over the evaluation pipeline, there is an explicit conversion to a lazy sequence with Iterable<T>.asSequence() function."
To run a Kotlin class you are actually running a special class that is created at the file level that hold your main() and other functions that are top-level (outside of a class or interface).  So if your code is:
You can also put your main() into a class with a companion object and make it static using the JvmStatic annotation.  Therefore your class name is the one you chose:
"If in Intellij (if it is your IDE) you can right click on the main() function and select Run, it will create a runtime configuration for you and show the fully qualified class name that will be used.  You can always use that if you are unsure of the name of the generated class."
"If you want to lazy process a chain, you can convert to a Sequence using asSequence() before the chain.  At the end of the chain of functions, you usually end up with a Sequence as well.  Then you can use toList(), toSet(), toMap() or some other function to materialize the Sequence at the end."
"First, you can define a comparator using the compareBy() method and pass it to the sortedWith() extension method to receive a sorted copy of the list:"
"We are done with requesting the all needed permissions depending on the device's SDK so far. Now we need to block the API call pathways to be able to check the permissions. Somewhere where you implement bluetooth scanning put a function like startScanning() as in the code example below, instead of using the BleScanner.scan() API directly. All the following functions must be in the same activity or fragment."
"This means that when you put an Int in an Array<Int>, it will always be boxed (specifically, with an Integer.valueOf() call). In the case of IntArray, no boxing will occur, because it translates to a Java primitive array."
"To create a copy of a collection, use the toList() or toSet() methods, depending on the collection type you need. These methods always create a new copy of a collection; they also perform a shallow copy."
"For other classes, there is no Kotlin-specific cloning solution. You can use .clone() if it suits your requirements, or build a different solution if it doesn't."
"If you don't care about the invalid values, then you could combine toIntOrNull() with the safe call operator and a scope function, for example:"
Adding null safety to new or existing methods that cannot be called on a null.  For example the extension function for String of String?.isNullOrBlank() allows you to use that function even on a null String without having to do your own null check first.  The function itself does the check before calling internal functions.  See documentation for extensions with Nullable Receiver
When you want to add for (item in collection) { ... } support to a class that does not currently support that usage.  You can add an iterator() extension method that follows the rules described in the for loops documentation -- even the returned iterator-like object can use extensions to satisfy the rules of providing next() and hasNext().
"Currently (Kotlin since M14 including up to 1.0 betas), to run a Kotlin class you are actually running a special class that is created at the file level that hold your main() and other functions that are top-level (outside of a class or interface).  So if your code is:"
Or you can also put your main() into a class with a companion object and make it static using the JvmStatic annotation.  Therefore your class name is the one you chose:
"When you write val a = mutableListOf(), you're saying ""I want a mutable list, and I don't particularly care about the implementation"". When you write, instead, val a = ArrayList(), you're saying ""I specifically want an ArrayList""."
"First of all, the argument of fromInt() should be an Int, not an Int?. Trying to get a Type using null will obviously lead to null, and a caller shouldn't even try doing that. The Map has also no reason to be mutable. The code can be reduced to:"
Beware that Scanner is somewhat slow. This may be important in some cases like competitive programming where program's execution on large inputs could be made up to two times faster just by replacing Scanner with plain readLine. Even my suboptimal readString() implementation tokenizing via sequence is slightly faster. It allows to read input tokens until any next whitespace unlike Kotlin's built-in readLine().
"It will actually be Serializable if it is a function reference (SomeClass::someFunction) or a lambda. But it might not be, if it is some custom implementation of the functional interface () -> Unit, so you should check that and handle the cases when it's not."
"Let's say you create a higher order function that takes a lambda of type () -> Unit (no parameters, no return value), and executes it like so:"
"The launch just creates new coroutine, while CommonPool dispatches coroutines to a ForkJoinPool.commonPool() which does use multiple threads and thus executes on multiple CPUs in this example."
"This line replaces multiple whitespaces with a single space. 
Note the explicit toRegex() call, which makes a Regex from a String, thus specifying the overload with Regex as pattern."
"In Swift, just like in Java 8, the closure captures a strong reference to self (this in Java and Kotlin) only if it accesses a property of the instance, such as self.someProperty, or if the closure calls a method on the instance, such as self.someMethod()."
"Note: Use job.await() instead of job.join() because await() rethrows exceptions, but join() does not. If you use join() you will need to check job.isCompletedExceptionally after the job completes."
"That's how Fragments on the back stack work (and Navigation just uses the existing Fragment APIs): the Fragment's view is destroyed, but the Fragment itself is not destroyed - they are kept in the CREATED state until you hit the back button and return to the Fragment (after which onCreateView() will be called again and you'll move back up to RESUMED)."
"Here is a quick version of a resettable lazy, it could be more elegant and needs double checked for thread safety, but this is basically the idea.  You need something to manage (keep track) of the lazy delegates so you can call for reset, and then things that can be managed and reset.  This wraps lazy() in these management classes."
"Edit: Since Kotlin 1.3.50, following the technique described below to get type information for a reified type parameter is no longer necessary. Instead, you can use typeOf<T>() on reified type parameters. This function is a compiler intrinsic, and the compiler processes its call sites by emitting the code that builds a representation of the type as a KType at runtime. The type, therefore, must be known at compile time, which is ensure by the type parameter being reified."
This represents a 閳ユ竾unction literal with receiver閳? It閳ユ獨 a function parameter with a function type () -> Unit and SCRIPT as it閳ユ獨 receiver.
"In your Activity, since your GroupAdapter has no dependencies, you can instantiate it at the call site to avoid dealing with lazy loading it. And you can set it to the RecyclerView in onCreate() immediately."
"If you do something in setupViewModel() that updates a view immediately, you'll have a crash, so you should move it after calling setContentView()."
"I am predicting that the change in the nested list is going to look weird when the view is being recycled rather than just updated, because it will animate the change from what was in the view previously, which could be from a different item. So we should probably track the old item key and avoid the animation if the new key doesn't match. I think this can be done in the submitList() callback parameter to run after the list contents have been updated in the adapter by calling notifyDataSetChanged(), but I haven't tested it."
"But these do not close the stream.  Make sure you check the API documentation for all of the IO functions you use to be sure which ones close and which do not.  Usually, if they include the word use (such as useLines() or use()) they close the stream after.  An exception is that File.readText() differs from Reader.readText() in that the former does not leave anything open and the latter does indeed require an explicit close."
"This happens because the Kotlin compiler tries to generate a getter for val context declared in your class primary constructor, namely a method getContext(), but the base class ArrayAdapter<T> already has such a method."
"Here I omitted the copy constructors and made the properties abstract, so the child class has all the properties. I also made the child class a data class. If you need to clone the class, you can simply call account.copy()."
"If you want to do a break you need something outside the loop that you can return from, here we will use the run() function to help us:"
Instead of run() it could be let() or apply() or anything naturally you have surrounding the forEach that is a place you want to break from.  But you will also skip the code within the same block following the forEach so be careful.
"The coroutine you launch suspends itself each time it calls suspendHere(). It writes the continuation callback to the continuation property, and then you explicitly use that continuation to resume the coroutine."
"The code uses the Unconfined coroutine dispatcher which does no dispatching to threads at all, it just runs the coroutine code right there where you invoke continuation.resume()."
"But let's assume it did call  suspendCoroutine. In that case the coroutine is no longer running on any thread. It is suspended and can't continue until some code, somewhere, calls continuation.resume(). That code could be running on any thread, any time in the future."
Android Activities are a good example of a use of lateinit. Activities must have a no args constructor and their lifecycle only really starts with onCreate().
Why your scrolledUp binding did work though? Because type () -> Unit has no need for generics. It could have worked even with Runnable.
Sadly I think it is not possible to get completely rid of a explicit access to the element. Since to do that you would need a lambda parameter of type T.() -> T but then you wouldn't be able to call that parameter without an instance of Tand being T a generic there is no clean and safe way to acquire this instance.
"Kotlin is great for writing your own Domain Specific Languages, also called type-safe builders. As you mentioned, the Anko library is an example making use of DSLs. The most important language feature you need to understand here is called ""Function Literals with Receiver"", which you made use of already: Test.() -> Unit"
The html() function expects such a function literal with receiver with HTML as the receiver. In the function body you can see how it is used: an instance of HTML is created and the init is called on it.  
"The caller of such an higher-order function expecting a function literal with receiver (like html()) you can use any visible HTML function and property without additional qualifiers (like this e.g.), as you can see in the call:"
"Is there a way to extract the whole block into a separate method? So that in the onCreate method, I could simply change the TextView into something like: val username = getUsername() tv_greet_user.text = ""Hello, $username"""
"Please note that the spread operator is only defined for arrays, and cannot be used on a list directly. When dealing with a list, use e.g.toTypedArray() to transform it to an array:"
"Android Extensions plugin now includes an automatic Parcelable implementation generator. Declare the serialized properties in a primary constructor and add a @Parcelize annotation, and writeToParcel()/createFromParcel() methods will be created automatically:"
"In order to use the ExampleClass, you need to create an instance of it: ExampleClass().example(), but with an object, Kotlin creates a single instance of it for you, and you don't ever call it's constructor, instead you just access it's static instance by using the name: ExampleObject.example()."
Now you can create a kotlin file with empty main() method and then you can run the code directly using run icon on left(of 7th line) in android studio (AS version: 3.5.3 ) editor like
"And as a suggestion , if you're using Kotlin, i really recommend using Kotlin extensions in your activity such as : import kotlinx.android.synthetic.main.activity_page.* or if you're using a custom view : kotlinx.android.synthetic.main.view_layout.view.*
after that, in onCreat() method of an activity , you'll only have to call the id, for example : my_edit_text_ID.text = ""Kotlin Dbest!"", or from a custom view : mCostumView.my_edit_text_ID.text = ""Kotlin Dbest!"""
"The two models are similar, and one predates the other.  Delegates.notNull() (api reference) is based on delegated properties and was the original, and later came lateinit (Late Initialized Properties).  Neither cover all possible use cases and neither should be used unless you can control the lifecycle of the class and know for sure that they will be initialized before being used."
"If for some reason you want the same Utils.foo() syntax in both Java and Kotlin, the solution with an object and then @JvmStatic per method is the way to do that, as already shown by @marianosimone in this answer."
You need to pass Array<WeatherObject>::class.java for class type and then convert result into List. No need to change registerTypeAdapter() function call. 
"Apart from JVM errors, I believe exceptions due to programming errors shouldn't really be handled in a way that bloats the business code either. Using error(), check(), require() in the right places will make use of exceptions to detect bugs that cannot be caught by the compiler (IllegalStateException, IllegalArgumentException). It often doesn't make sense to catch these exceptions in business code, because they appear when the programmer made a mistake and the logic of the code is broken. You should instead fix the code's logic."
"In your case the TextView class contains a getter CharSequence getText() and a setter void setText(CharSequence). If you had a variable of type TextView your code would work fine. But you have a variable of type EditText. And the EditText class contains an overridden getter Editable getText(), which means that you can get an Editable for an EditText and set an Editable to an EditText. Therefore, Kotlin reasonably creates a synthetic property text of type Editable. The String class is not Editable, that's why you cannot assign a String instance to the text property of the EditText class."
"Kotlin positions its numeric types (Int, Long, Double etc.) as not being nested into each other, there is no subtyping relationship between these types. That's why the cast intNum as Double does not succeed in Kotlin. That's also why there's no implicit conversions between these types. Instead, the numeric conversion is done with the corresponding functions (e.g. .toDouble())"
"<...> What is the most efficient way to cast values? There is a .toDouble() function, but this seems inefficient and unwieldy."
"The most efficient way is to use the numeric conversion functions like .toDouble(). In fact, these functions are intrinsified, and there is no function call overhead when you use them. They are compiled closely to what javac would produce for a Java numeric cast or an implicit conversion. You can inspect the bytecode that the Kotlin compiler produces to find out what it's under the hood and whether a specific conversion introduces any overhead."
But there's actually a more elegant solution without the use of reflection. Define a parameter of method type () -> T and use constructor references. Here's my related question about constructor references and here's the code:
A view will return a valid value for View.getHeight()only after it has been measured. The measuring itself will automatically happen by the system when the view is about to be displayed on screen.
"So, to know the height of a view element, before it has been measured and laid out by the system, we will need to invoke the view.measure() function manually."
"In this case doStuff is being assigned the result of the call to  whatever(""message"") { doNothing() } which is a function of type ()->Unit; and if you add a semicolon it is being assigned the function { doNothing() } which is also of type ()->Unit.  So the code is valid both ways.  But I have not seen something like this occur naturally since everything has to line up perfectly.  The feature suggested emit keyword or ^ hat operator would have made this case impossible, and it was considered but dropped before 1.0 due to strongly opposed opinions and time constraints."
"The WifiManager.startScan() usage is limited to:
- Each foreground app is restricted to 4 scans every 2 minutes.
- All background apps combined are restricted to one scan every 30 minutes."""
"since I don't know if observeForever() will be cleared on onCleared() if my view is destroyed, so it won't keep the observer alive if the view dies."
"Create a local variable job and initialize it in onCreate(). (I tried to write private val job: Job = Job(), but bumped into problem that in ViewPager you will create Fragments and their jobs. As we will cancel the job in onDestroy() during swiping in ViewPager, we should recreate the job)."
"So, to call such a function from outside the class you have to provide two receivers. Kotlin doesn't have any syntax to do that explicitly like (x, ""abc"").stringExtension(), but you can provide the dispatch receiver implicitly using an extension lambda:"
"Your example illustrates this.聽 It has an interface (Action) with one abstract method (run()).聽 It has a function (runAction()) which takes an instance of that interface.聽 And it has some code which wants to call that function, passing just the code for the run() method."
"The syntax is not valid, because c = reader.read() is not an expression in Kotlin 閳?this prevents all the == vs = bugs."
"Fast forward 5+ years, and we finally introduced a new method that doesn閳ユ獩 have this awkward behavior anymore. And since Android APIs have moved on quite a bit since 2015, we also use a (slightly) more modern method signature: Task<DataSnapshot> get()."
"What consume() or consumeAllChanges() does is it prevents pointerInput above it or on parent to receive events by returning PointeInputChange.positionChange() Offset.Zero, PointerInputChange.isConsumed true.  Since drag, scroll or transform gestures check if PointeInputChange.isConsumed is true they will never get any event if you consume them in previous pointerInput."
"You should only call navigate() as part of a callback and not as part
of your composable itself, to avoid calling navigate() on every
recomposition."
Here response.body() was not able to parse response as LoginResponse class object which was eventually causing issue further more on navigation.
See the red line? What it actually holds is the address of an object from the memory and not an image url. This is happening because you are calling toString() method on the downloadUrl object. So the way you are get the donwload url is not correct. This is the correct way for getting the url. Once you get url of the image and you add it to the database and everything will work as expected.
If you only check if a Task is successful it doesn't mean that the document where the reference is pointing to actually exists. It means that your get() call is completed with no errors.
".allowMainThreadQueries() is a way to disable an error check, but that error is there for a reason. You're not supposed to be reading the data on the UI thread, because with enough data, your app will freeze (ANR)."
"Basically, the code is seen as a call to extension Something.logger().  The problem is that the following could also be true creating ""pollution"" on other classes:"
"Note:  The unwrapCompanionClass() method ensures that we do not generate a logger named after the companion object but rather the enclosing class.  This is the current recommended way to find the class containing the companion object.  Stripping ""$Companion"" from the name using removeSuffix() does not work since companion objects can be given custom names."
"NOTE: cancellable() will ensure the flow is terminated before new items are emitted to collect { } if its job is cancelled, though flow builder and all implementations of SharedFlow are cancellable() by default."
"Now when you create an instance of this interface you only need to provide a compulsory implementation for onSee() method, rest are optional"
"The for loop, or forEach depends on your style.  No reason to use append(x) since that is basically write(x.toString()) and you already give it a string.  And println(x) basically does write(x) after converting a null to ""null"".  And println() does the correct line ending."
"If you are using data classes of Kotlin, they can already be output because they have a nice toString() method already."
"Also you can use out.newLine() instead of \n if you want it to be correct for the current operating system in which it is running.  And if you were doing that all the time, you would likely create an extension function:"
"Second, for modifying a list ""in-place"" you need to use a type of list that is mutable.  In your sample you use listOf which returns the List<T> interface, and that is read-only.  You need to directly reference the class of a mutable list (i.e. ArrayList), or it is idiomatic Kotlin to use the helper functions arrayListOf or linkedListOf to create a MutableList<T> reference.  Once you have that, you can iterate the list using the listIterator() which has a mutation method set()."
"The extension functions above optimize a little by not setting the value if it has not changed to a different instance, checking that using  === or !== is Referential Equality.  It isn't worth checking equals() or hashCode() because calling those has an unknown cost, and really the referential equality catches any intent to change the value.  "
"Here are unit test cases showing the functions working, and also a small comparison to the stdlib function map() that makes a copy:"
"Any is not java.lang.Object; in particular, it does not have any 
  members other than equals(), hashCode() and toString(). Please 
  consult the Java interoperability section for more details."
"The above sample relies on the configuration avoidance APIs. If you need or want to eagerly configure or register container elements, simply replace named() with getByName() and register() with create()."
"EDIT:
Also note that using withType<T> { } will immediately create and configure the task, and must be avoided using withType<T>().configureEach {} instead (source)."
"Alternatively, we can add () at the end when we declare foo2(), as shown in the following example. As such, the lambda expression will be invoked when calling foo3(). But this is not a good pattern."
Caution: Using mutable objects such as ArrayList<T> or mutableListOf() as state in Compose will cause your users to see incorrect or stale data in your app.
"EDIT: As mentioned in comments, this is probably a bad idea. Accepting a () -> T is probably the most reasonable way of achieving this. That said, the following technique will achieve what you're looking for, if not necessarily in the most idiomatic way."
Add a <queries> element to your manifest that lists all of those possible Intent structures that you want to be able to use with resolveActivity()
"This way inside the use block your resource will be available, afterwards you will get back result, which is what doThing() returns, and your resource will be closed. As you haven't stored it in a variable you also avoid accidentally using the resource after it is closed."
The global functions such as fun myFunc11() { ... } defined in file named i.e. Global.kt are compiled to static methods on a class named GlobalKt as described in the documentation.
"After this the tests still didn't run, but that was because I'm using JUnit4. So I just had to add useJUnitPlatform() which makes this the final code"
"Before I go on, a general note: your getItem() function is suspendable, you have no need to submit it to the IO dispatcher. All your coroutines can run on the main thread."
"Here the magic is in the .flatMapMerge operation. You give it a function (T) -> Flow<R> and it will execute it sequentially on all the input, but then it will concurrently collect all the flows it got. Note that I couldn't simplify flow { emit(getItem()) } } to just flowOf(getItem()) because getItem() must be called lazily, while collecting the flow."
You might want to consider changing your minSDK to 19 and use getExternalFilesDir() to get a path that doesn閳ユ獩 require any permissions. 
"In onItemSelected(), the selectedItemView argument may be null when nothing is selected. Change its type to View? instead of View and properly handle the case where nothing is selected."
"However, by using runBlocking() you have shot yourself in the foot and wrote blocking code that just formally uses an async API to no good effect."
"The server app sends the file's content URI back to the client app in an Intent. This Intent is passed to the client app in its override of onActivityResult(). Once the client app has the file's content URI, it can access the file by getting its FileDescriptor."
"if you want the default value to be seen by the caller, use default values.  They will show up in IDE tooltips (i.e. Intellij IDEA) and let the caller know they are being applied as part of the contract.  You can see in the following screenshot that calling foo() will default some values if values are omitted for x and y:"
You will not be able to use the default value in the 2nd version (other than via reflection callBy).  Instead all foo() calls without parameters still call the first version of the function.  So you need to instead use distinct overloads without the default or you will confuse users of the function:
"The platform() function used to import the Firebase Bill of Materials is not available in Kotlin Multiplatform plugin閳ユ獨 KotlinDependencyHandler but only in Gradle閳ユ獨 standard DependencyHandler. It also does not seem that a fix is coming soon. As a result, you need to specify Gradle's handler explicitly."
"Kotlin doesn't perform implicit type conversion because of this thing happens. If Kotlin did implicit type conversions, b should be 1. but since a is a boxed Int and b is a boxed Long, a == b yields false and falls into contradiction, since its == operator checks for equals() and Long's equals() checks other part to be Long as well."
"This adds a more explicit generic parameter to the Collectors.toList() call, preventing the bug which occurs during inference of the generics (which are somewhat convoluted for that method return type Collector<T, ?, List<T>>, eeeks!?!)."
Now you have forEach and many other functions available to you while still consuming the Stream lazily and only once.  Using myStream.iterator() is another way but may not have as much functionality as a Sequence.
And of course at the end of some processing on the Sequence you can toList() or toSet() or use any other of the Kotlin extensions for changing collection types.
"We can change your code slightly to get the file list from File instead, and you would just use toList() at the end:"
"With Java reflection, you can filter out these synthetic functions and constructors by checking isSynthetic() and finding the one that is not."
It is important to use the object keyword before the construction of the request in order to be able to override the getHeaders() method.
I once had this issue too. My solution is to use a seeded random object instead of calling the function Random.nextSomething(). Then I seed currentTimeInMillis as the seed.
"There is no way you can return your downloadUri as a result of a method and this is because Firebase APIs are asynchronous. This means that onComplete() function returns immediately after it's invoked, and the callback from the Task it returns, will be called some time later. So unfortunately there are no guarantees about how long it will take, it may take from a few hundred milliseconds to a few seconds before that data is available. Because that method returns immediately, the value of your downloadUri variable you're trying to return, will not have been populated from the callback yet."
"A quick solve for this problem would be to use the value of your downloadUri variable only inside the onComplete() method. Basically, all the logic that exist inside your uploadAudioFile() method should be moved inside the callback. If you want to use that value outside the callback, I recommend you see the last part of my anwser from this post in which I have explained how it can be done using a custom callback."
"To solve this possible inconsistency (that would lead to broken type-safety), all bound class references are covariant: someBase()::class is KClass<out Base>, meaning that at runtime someBase() might be a subtype of Base, and therefore this might be a class token of a subtype of Base."
The placeholder image you are seeing is from com.android.internal.R.drawable.unknown_image and is set if the ImageGetter returns null. From the function startImg() in Html.
"If the scheme of the returned Uri happens to be file, then getPath() will return you a filesystem path to the file. However, there is no guarantee that you can use that file, and the file scheme has largely been banned since Android 7.0."
"The error message indicates that the audio recording is failed due to incorrect state.
This error ""AUDIO_RECORD_START_STATE_MISMATCH"" tells that when the start() methods is called the audio recording already is in progress.
It is possible there is a conflict between media-recording and WEBRTC audio recording."
I had the same problem and I discovered that this is a bug of Kotlin library. (I am so serious.) You cannot call intArrayOf() method.
"This answer describes the process of retrieving the stack trace. Already have the stack trace? Read up on stack traces in ""What is a stack trace, and how can I use it to debug my application errors?"""
"Every time an Android application crashes (or any Java application for that matter), a Stack trace is written to the console (in this case, logcat). This stack trace contains vital information for solving your problem."
"In the bottom bar of the window, click on the Logcat button. Alternatively, you can press alt+6. Make sure your emulator or device is selected in the Devices panel. Next, try to find the stack trace, which is shown in red. There may be a lot of stuff logged into logcat, so you may need to scroll a bit. An easy way to find the stack trace is to clear the logcat (using the recycle bin on the right), and let the app crash again."
"If you want to return the values from an async operation through a  method/function, you can define your own callbacks in your method/function to use these values as they are returned from these operations."
Here we can assume we get contents of the proper format by passing in the proper mime type to our request (as there is no requirement that a text file end in exactly the .txt extension as part of its path):
Then in your xml folder you now have to create a file named network_security_config just like the way you have named it in the Manifest and from there the content of your file should be like this to enable all requests without encryptions:
"This is a classic issue with asynchronous web APIs. You cannot return something now, that hasn't been loaded yet. With other words, you cannot simply return the places list as a result of a method because it will always be empty due the asynchronous behavior of the onComplete function. Depending on your connection speed and the state, it may take from a few hundred milliseconds to a few seconds before that data is available."
"But not only Cloud Firestore loads data asynchronously, almost all of modern other web APIs do, since it may take some time to get the data. But let's take an quick example, by placing a few log statements in the code, to see more clearly what I'm talking about."
"The initial response for most developers is to try and ""fix"" this asynchronous behavior, which I personally recommend against it. Here is an excelent article written by Doug Stevenson that I'll highly recommend you to read."
"If you want to use the list outside, there is another approach. You need to create your own callback to wait for Firestore to return you the data. To achieve this, first you need to create an interface like this:"
"You input string, 2006-03-25T10:30:00+12:00 is already in the default format used by OffsetDateTime#parse and therefore, you do not need to use a formatter explicitly in order to parse your input date-time string."
"y specifies the year-of-era (era is specified as AD or BC) and is always a positive number whereas u specifies the year which is a signed (+/-) number. Normally, we do not use + sign to write a positive number but we always specify a negative number with a - sign. The same rule applies for a year. As long as you are going to use a year of the era, AD (which is mostly the case), both, y and u will give you the same number. However, the difference occurs when you use a year of the era, BC e.g. the year-of-era, 1 BC is specified as year, 0; the year-of-era, 2 BC is specified as year, -1 and so on. You can understand it better with the following demo:"
"In Kotlin, you cannot access a nullable value without being sure it is not null (Checking for null in conditions), or asserting that it is surely not null using the !! sure operator, accessing it with a ?. Safe Call, or lastly giving something that is possibly null a default value using the ?: Elvis Operator."
"For your 1st case in your question you have options depending on the intent of the code you would use one of these, and all are idiomatic but have different results:"
"For your 2nd case in your question in the question with Map, if you as a developer are sure of the result never being null, use !! sure operator as an assertion:"
"Note: in the examples below I am using explicit types to make the behavior clear.  With type inference, normally the types can be omitted for local variables and private members."
The !! operator asserts that the value is not null or throws an NPE.  This should be used in cases where the developer is guaranteeing that the value will never be null.  Think of it as an assert followed by a smart cast.
"If you protect access to a nullable type with a null check, the compiler will smart cast the value within the body of the statement to be non-nullable.  There are some complicated flows where this cannot happen, but for common cases works fine."
"Some things do not allow the null check to smart cast for the later use of the variable.  The example above uses a local variable that in no way could have mutated in the flow of the application, whether val or var this variable had no opportunity to mutate into a null.  But, in other cases where the compiler cannot guarantee the flow analysis, this would be an error:"
"The lifecycle of the variable nullableInt is not completely visible and may be assigned from other threads, the null check cannot be smart cast into a non-nullable value. See the  ""Safe Calls"" topic below for a workaround."
"Another case that cannot be trusted by a smart cast to not mutate is a val property on an object that has a custom getter.  In this case, the compiler has no visibility into what mutates the value and therefore you will get an error message:"
In one of the examples above we had a case where we did an if check but have the chance another thread mutated the value and therefore no smart cast.  We can change this sample to use the safe call operator along with the let function to solve this:
"in some cases, it warrants different return types that include the status of the method call and the result if successful.  Libraries like Result give you a success or failure result type that can also branch your code.  And the Promises library for Kotlin called Kovenant does the same in the form of promises."
"when overriding methods from Java where Kotlin isn't sure about the nullability of the Java code, you can always drop the ? nullability from your override if you are sure what the signature and functionality should be.  Therefore your overridden method is more null safe.  Same for implementing Java interfaces in Kotlin, change the nullability to be what you know is valid."
there is a Safe (nullable) cast operator as well that allows a cast to non-nullable type return null if not possible. But I do not have a valid use case for this that isn't solved by the other methods mentioned above.
"Search if there's any entry of type activity, service, receiver, or provider which does not have an exported attribute, and for each entry follow below ""Fix found entries"" section (or see once for how to set exported attribute)."
"But Android doesn't work like that, you can easily end up crashing because after low memory condition happens, only the current Activity gets recreated at first, previous Activity is recreated on back navigation, and all static variables are nulled out (because the process is technically restarted)."
"In Android Studio 4.0, after you use Run from Android Studio instead of starting the app from launcher, the Terminate button SOMETIMES works a bit differently and MIGHT force-stop your app making it forget your task state on your attempt. In that case, just try again, launching the app from launcher. It will work on your second try."
"The ability to refer to a view directly by it's ID/name in Kotlin is called ""synthetic properties"" and it is a feature of a project plugin called Kotlin Android Extensions, which is no longer supported or included in new projects. (See below for explanation.)"
"Tutorials written between 2017 and 2020 often make use of this feature, and if they haven't been updated, they probably don't even mention it by name, because it was taken for granted to be an included plugin in new projects."
One thing to consider is that Jetpack Compose is becoming the default and recommended way to do UI on Android. You might consider switching to a tutorial that teaches that instead of traditional XML view layouts. But if you still want to learn traditional views:
"The quick and easy way to get your view reference is to use findViewById. The type of View should go inside the brackets <>. In an Activity, it looks like this:"
"List<T> and MutableList<T> are interfaces which have different implementations: ArrayList<T>, LinkedList<T> etc. Memory representation and operations logic of lists are defined in concrete implementation, e.g. indexing in a LinkedList<T> goes through the links and takes O(n) time whereas ArrayList<T> stores its items in a dynamically allocated array."
"Arrays have fixed size and cannot expand or shrink retaining identity (you need to copy an array to resize it). As to the lists, MutableList<T> has add and remove functions, so that it can increase and reduce its size."
"Arrays are optimized for primitives: there are separate IntArray, DoubleArray, CharArray etc. which are mapped to Java primitive arrays (int[], double[], char[]), not boxed ones (Array<Int> is mapped to Java's Integer[]). Lists in general do not have implementations optimized for primitives, though some libraries (outside JDK) provide primitive-optimized lists."
"List<T> and MutableList<T> are mapped types and have special behaviour in Java interoperability (Java's List<T> is seen from Kotlin as either List<T> or MutableList<T>). Arrays are also mapped, but they have other rules of Java interoperability."
"Certain array types are used in annotations (primitive arrays, Array<String>, and arrays with enum class entries), and there's a special array literal syntax for annotations. Lists and other collections cannot be used in annotations."
"As to the usage, good practice is to prefer using lists over arrays everywhere except for performance critical parts of your code, the reasoning is the same to that for Java."
"Any block of code in Kotlin may have a type (or even multiple types) as a receiver, making functions and properties of the receiver available in that block of code without qualifying it."
"Doesn't make much sense, right? In fact, assigning this to a function type of (Int) -> Long - where Int is the (only) parameter, and the return type is Long - would rightfully result in a compilation error. You can fix this by simply qualifying the function call with the implicit single parameter it. However, for DSL building, this will cause a bunch of issues:"
"Yes. A block of code can have multiple receivers, but this currently has no  expression in the type system. The only way to achieve this is via multiple higher-order functions that take a single receiver function type. Example:"
"In the body of a generic function like myGenericFun, you can't access the type T because it's only available at compile time but erased at runtime. Therefore, if you want to use the generic type as a normal class in the function body you need to explicitly pass the class as a parameter as shown in myGenericFun."
"If you create an inline function with a reified T, the type of T can be accessed even at runtime, and thus you do not need to pass the Class<T> additionally. You can work with T as if it was a normal class - e.g. you might want to check whether a variable is an instance of T, which you can easily do then: myVar is T."
"You can only use reified in combination with an inline function. By doing so, you instruct the compiler to copy the function's bytecode to every spot the function is invoked from (the compiler ""inlines"" the function). When you call an inline function with reified type, the compiler has to be able to know the actual type passed as a type argument so that it can modify the generated bytecode to use the corresponding class directly. Therefore a call like myVar is T becomes myVar is String in the bytecode (if the type argument is String)."
"Let's have a look at an example that shows how helpful reified can be.
We want to create an extension function for String called toKotlinObject that tries to convert a JSON string to a plain Kotlin object with a type specified by the function's generic type T. We can use com.fasterxml.jackson.module.kotlin for this and the first approach is the following:"
"Suspending functions are at the center of everything coroutines.
 A suspending function is simply a function that can be paused and resumed at a later time. They can execute a long running operation and wait for it to complete without blocking."
"The syntax of a suspending function is similar to that of a regular function except for the addition of the suspend keyword. It can take a parameter and have a return type. However, suspending functions can only be invoked by another suspending function or within a coroutine."
"Under the hood, suspend functions are converted by the compiler to another function without the suspend keyword, that takes an addition parameter of type Continuation<T>. The function above for example, will be converted by the compiler to this:"
Continuation<T> is an interface that contains two functions that are invoked to resume the coroutine with a return value or with an exception if an error had occurred while the function was suspended.
"lazy { ... } delegate can only be used for val properties, whereas lateinit can only be applied to vars, because it can't be compiled to a final field, thus no immutability can be guaranteed;"
"lateinit var has a backing field which stores the value, and by lazy { ... } creates a delegate object in which the value is stored once calculated, stores the reference to the delegate instance in the class object and generates the getter for the property that works with the delegate instance. So if you need the backing field present in the class, use lateinit;"
"lateinit var can be initialized from anywhere the object is seen from, e.g. from inside a framework code, and multiple initialization scenarios are possible for different objects of a single class. by lazy { ... }, in turn, defines the only initializer for the property, which can be altered only by overriding the property in a subclass. If you want your property to be initialized from outside in a way probably unknown beforehand, use lateinit."
"Initialization by lazy { ... } is thread-safe by default and guarantees that the initializer is invoked at most once (but this can be altered by using another lazy overload). In the case of lateinit var, it's up to the user's code to initialize the property correctly in multi-threaded environments."
"A Lazy instance can be saved, passed around and even used for multiple properties. On contrary, lateinit vars do not store any additional runtime state (only null in the field for uninitialized value)."
"A lambda passed to by lazy { ... } may capture references from the context where it is used into its closure.. It will then store the references and release them only once the property has been initialized. This may lead to object hierarchies, such as Android activities, not being released for too long (or ever, if the property remains accessible and is never accessed), so you should be careful about what you use inside the initializer lambda."
"Every time I hear about the ""pass-by-value"" vs ""pass-by-reference"" Java debate I always think the same. The answer I give: ""Java passes a copy (pass-by-value) of the reference (pass-by-reference)"". So everyone is happy. I would say Kotlin does the same as it is JVM based language."
"OK, so it's been a while since this answer and I think some clarification should be included. As @robert-liberatore is mentioning in the comments, the behaviour I'm describing is true for objects. Whenever your methods expect any object, you can assume that the JVM internally will make a copy of the reference to the object and pass it to your method. That's why having code like"
"behaves like it does. You're copying the reference to the list, so ""reassigning it"" will take no effect in the real object. But since you're referring to the same object, modifying its inner content will affect the outer object."
"This is something you may miss when defining your attributes as final in order to achieve immutability. You won't be able to reassign them, but there's nothing preventing you from changing its content"
"Of course, this is true for objects where you have a reference. In case of primitives, which are not a reference to an object containing something but ""something"" themselves, the thing is different. Java will still make a copy of the whole value (as it does with the whole reference) and pass it to the method. But primitives are just values, you can't ""modify its inner values"". So any change inside a method will not have effect in the outer values"
"In Kotlin you ""don't have"" primitive values. But you ""do have"" primitive classes. Internally, the compiler will try to use JVM primitive values where needed but you can assume that you always work with the boxed version of the JVM primitives. Because of that, when possible the compiler will just make a copy of the primitive value and, in other scenarios, it will copy the reference to the object. Or with code"
"For Sequence<T>, the extension functions perform lazily where possible, similarly to Java Streams intermediate operations. For example, Sequence<T>.map { ... } returns another Sequence<R> and does not actually process the items until a terminal operation like toList or fold is called."
"Sequence<T> is intended for lazy usage and efficient pipelining when you want to reduce the work done in terminal operations as much  as possible, same to Java Streams. However, laziness introduces some overhead, which is undesirable for common simple transformations of smaller collections and makes them less performant. "
"You should scope your concurrency appropriately using structured concurrency. Your coroutines can leak if you don't do this. In your case, scoping them to the processing of a single message seems appropriate."
"If one of the calls to restService.post(id) fails with an exception, the example will immediately rethrow the exception, and all the jobs that hasn't completed yet will leak. They will continue to execute (potentially indefinitely), and if they fail, you won't know about it."
"launch is used to fire and forget coroutine. It is like starting a new thread. If the code inside the launch terminates with exception, then it is treated like uncaught exception in a thread -- usually printed to stderr in backend JVM applications and crashes Android applications. join is used to wait for completion of the launched coroutine and it does not propagate its exception. However, a crashed child coroutine cancels its parent with the corresponding exception, too."
"async is used to start a coroutine that computes some result. The result is represented by an instance of Deferred and you must use await on it. An uncaught exception inside the async code is stored inside the resulting Deferred and is not delivered anywhere else, it will get silently dropped unless processed. You MUST NOT forget about the coroutine you閳ユ獫e started with async."
"There are functions in the Kotlin stdlib for average, count, distinct, filtering, finding, grouping, joining, mapping, min, max, partitioning, slicing, sorting, summing, to/from arrays, to/from lists, to/from maps, union, co-iteration, all the functional paradigms, and more.  So you can use those to create little 1-liners and there is no need to use the more complicated syntax of Java 8."
.associateTo')
"One thing missing from both is batching by count, which is seen in another Stack Overflow answer and has a simple answer as well. Another interesting case is this one also from Stack Overflow: Idiomatic way to split sequence into three lists using Kotlin.  And if you want to create something like Stream.collect for another purpose, see Custom Stream.collect in Kotlin"
"and on it goes...  In all cases, no special fold, reduce, or other functionality was required to mimic Stream.collect.  If you have further use cases, add them in comments and we can see!"
In your case the private access modifier is redundant - isEmpty is private by default and can be accessed only by a getter. When you try to get your object's isEmpty property you call the get method in real. For more understanding of getters/setters in Kotlin: the two code samples below are equal:
Also I want to point out that this in a getter is not your property - it's the class instance. If you want to get access to the field's value in a getter or setter you can use the reserved word field for it:
"Non-local return (i.e. return from outer functions) from a lambda is only supported for local and inline functions, because if a lambda is not inlined (or a function is placed inside an object), it is not guaranteed to be called only inside the enclosing function (e.g. it can be stored in a variable and called later), and the non-local return would make no sense in this case."
"The vararg version of compareValuesBy is not inlined in the bytecode meaning anonymous classes will be generated for the lambdas. However, if the lambdas themselves don't capture state, singleton instances will be used instead of instantiating the lambdas everytime."
"As noted by Paul Woitaschek in the comments, comparing with multiple selectors will instantiate an array for the vararg call everytime. You can't optimize this by extracting the array as it will be copied on every call. What you can do, on the other hand, is extract the logic into a static comparator instance and reuse it:"
You need to use Annotation use-site targets since the default for a property declared in the constructor is to target the annotation on the constructor parameter instead of the getter (which will be seen by JavaBeans compliant hosts) when there are multiple options available.  Also using a data class might be inappropriate here (see note at end).
"NOTE: As mentioned in notes from others, you should likely consider NOT using a data class for entities if they use an auto-generated ID since it will not exist for new objects the same as for retrieved objects; and a data class will generate equals and hashCode to include all fields including the ones it should not.  You can read guidance about this from the Hibernate docs."
"Each case should be handled in a different way. For suspendable http calls you can use ktor http client. But sometimes there is no library for your case, so you can either write your own solution or ignore this warning."
"let - mostly used to avoid null checks, but can also be used as a replacement for run. The difference is, that this will still be the same as before and you access the re-scoped variable using it:"
The code above will add the apple to the basket only if it's not null. Also notice that it is now not optional anymore so you won't run into a NullPointerException here (aka. you don't need to use ?. to access its attributes)
"Other than the possible performance implications of the above, there's also convenience to consider. Primitive arrays can be left uninitialized and they will have default 0 values at all indexes. This is why IntArray and the rest of the primitive arrays have constructors that only take a size parameter:"
"In contrast, Array<T> doesn't have a constructor that only takes a size parameter: it needs valid, non-null T instances at all indexes to be in a valid state after creation. For Number types, this could be a default 0, but there's no way to create default instances of an arbitrary type T."
"This is actually a bug in the Kotlin Gradle plugin 1.1.2-4 inter-operation with the Android Gradle plugin 3.0.0-alpha1, caused by how the inputs and outputs of the tasks are set (and thus how the tasks are connected with the depends-on relation)."
"Then, in File -> Invalidate Caches / Restart閳?select Invalidate, and retry using Quick Documentation. It should display instantly. If it doesn't, select Invalidate and Restart, and you should be good to go."
"When you want to enhance, extend or change an existing API.  An extension function is the idiomatic way to change a class by adding new functionality.  You can add extension functions and extension properties. See an example in the Jackson-Kotlin Module for adding methods to the ObjectMapper class simplifying the handling of TypeReference and generics."
"When you want an inline default function for an interface, you must use an extension function to add it to the interface because you cannot do so within the interface declaration (inlined functions must be final which is not currently allowed within an interface).  This is useful when you need inline reified functions, for example this code from Injekt"
"Adding operators to existing classes such as + and * (specialization of #1 but you can't do this in any other way, so is mandatory).  See documentation for operator overloading"
"You want to control the scoping of when something is visible to a caller, so you extend the class only in the context in which you will allow the call to be visible.  This is optional because you could just allow the extensions to be seen always.  see answer in other SO question for scoping extension functions"
"You have an interface that you want to simplify the required implementation, while still allowing more easy helper functions for the user.  You can optionally add default methods for the interface to help, or use extension functions to add the non-expected-to-be-implemented parts of the interface.  One allows overriding of the defaults, the other does not (except for precedence of extensions vs. members)."
"A list of requests start to appear (network log) and after, say, a few seconds, all requests will complete executing. Here, we want to look for and inspect a request that has a Type like xhr. We can filter requests by clicking the filter icon and then selecting the desired type."
"First, Kotlin doesn't use the Java concept of static members because Kotlin has its own concept of objects for describing properties and functions connected with singleton state, and Java static part of a class can be elegantly expressed in terms of singleton: it's a singleton object that can be called by the class' name. Hence the naming: it's an object that comes with a class."
"In practice, in the current implementation of Kotlin compiling to the JVM, calling mutableListOf will produce an ArrayList, and there's no difference in behaviour: once the list is built, everything will behave the same."
"Likelier than not, the Kotlin team would only make that change if they figure the new implementation works better for most use cases. mutableListOf would then have you using that new list implementation transparently, and you'd get that better behaviour for free. Go with mutableListOf if that sounds like your case."
"Kotlin, compared to Java, seems to rely on packages model to a lesser degree (e.g. directories structure is not bound to packages). Instead, Kotlin offers internal visibility, which is designed for modular project architecture. Using it, you can encapsulate a part of your code inside a separate module."
"There are two separate worlds: the suspendable world (within a coroutine) and the non-suspendable one. As soon as you enter the body of runBlocking, you are in the suspendable world, where suspend funs behave like blocking code and you can't get to the next line until the suspend fun returns. coroutineScope is a suspend fun that returns only when all the coroutines inside it are done. Therefore the last line must print at the end."
"From the perspective of the code in the block, your understanding is correct. The difference between runBlocking and coroutineScope happens at a lower level: what's happening to the thread while the coroutine is blocked?"
"coroutineScope is a suspend fun. If your coroutine suspends, the coroutineScope function gets suspended as well. This allows the top-level function, a non-suspending function that created the coroutine, to continue executing on the same thread. The thread has ""escaped"" the coroutineScope block and is ready to do some other work."
"In your specific example: when your coroutineScope suspends, control returns to the implementation code inside runBlocking. This code is an event loop that drives all the coroutines you started within it. In your case, there will be some coroutines scheduled to run after a delay. When the time arrives, it will resume the appropriate coroutine, which will run for a short while, suspend, and then control will be again inside runBlocking."
"runBlocking is a low-level construct, to be used only in framework code or self-contained examples like yours. It turns an existing thread into an event loop and creates its coroutine with a Dispatcher that posts resuming coroutines to the event loop's queue."
"coroutineScope is a user-facing construct, used to delineate the boundaries of a task that is being parallel-decomposed inside it. You use it to conveniently await on all the async work happening inside it, get the final result, and handle all failures at one central place."
"I hope someday a concise, crossplatform, performant, universal for both console and files input parsing support would be introduced in Kotlin stdlib. Like readInt, readLong, etc global and Reader extension functions.
This would be very userful not only for competitive programming but also for learning Kotlin as first language.
A concept of reading a number shouldn't require first explaining collections, lambdas and monads."
"Important note: with the code as written here, the time taken to process elements is not taken into account by tickerFlow, so the delay might not be regular (it's a delay between element processing). If you want the ticker to tick independently of the processing of each element, you may want to use a buffer or a dedicated thread (e.g. via flowOn)."
"If you need to carry on doing your work while your ""subscribe"" does something for each ""tick"", you may launch a background coroutine that will read from this channel and do the thing you want:"
"It seems that your project is configured in such a way that you depend on kotlin-stdlib 1.1 and kotlin-reflect 1.0. The most likely case is that you already have an explicit dependency on kotlin-stdlib 1.1 but have no dependency on kotlin-reflect, and some other library (which you depend on) depends on kotlin-reflect 1.0."
"No Function instance will be created, instead, the code around the invocation of block inside the inlined function will be copied to the call site, so you'll get something like this in the bytecode:"
"The rationale behind these limitations is that future versions of
Kotlin may expand and/or change semantics of functions that return
Result type and null-safety operators may change their semantics when
used on values of Result type. In order to avoid breaking existing
code in the future releases of Kotin and leave door open for those
changes, the corresponding uses produce an error now. Exceptions to
this rule are made for carefully-reviewed declarations in the standard
library that are part of the Result type API itself."
"The code that follows launch invocation in {...} is called a suspending lambda. What is it and how are suspending lambdas and functions implemented (compiled) as well as standard library functions and classes like startCoroutines, suspendCoroutine and CoroutineContext is explained in the corresponding Kotlin coroutines design document."
"To use it in your coroutines, you wrap the dispatcher that you want to use with MyContext and give it the initial value of your data. This value will be put into the thread-local on the thread where the coroutine is resumed."
"The implementation above would also track any changes to the thread-local that was done and store it in this context, so this way multiple invocation can share ""thread-local"" data via context."
UPDATE: Starting with kotlinx.corutines version 0.25.0 there is direct support for representing Java ThreadLocal instances as coroutine context elements. See this documentation for details. There is also out-of-the-box support for SLF4J MDC via kotlinx-coroutines-slf4j integration module.
"For short, do not use forEach like map.forEach { t, u -> Log.i(""tag"", t + u) } (this is using Java 8 API, which does not work for Android API level <= 23).
Use it like map.forEach { (t, u) -> Log.i(""tag"", t + u) } (this is using Kotlin API).
(Not two parameters. Just one parameter that is a pair.)"
"Due to type erasure, actual generic arguments cannot be obtained through T::class token of a generic class. Different objects of a class must have the same class token, that's why it cannot contain actual generic arguments."
There is a techinque called super type tokens which can give actual type arguments in case when the type is known at compile time (it is true for reified generics in Kotlin because of inlining).
"One way to control execution order is to use a Channel - where lazily executed coroutine jobs are passed to the channel to be run in sequence. Unlike the Mutex, the Channel guarantees that the jobs are run in the order they are launched."
You can keep jobs from running at the same time with a Mutex and withLock call. The call order is not guaranteed if you make a bunch of calls in short succession. For example:
"If you must always run a then b you can make both of them suspend functions and call them from within a single scope (only allowing the complex call, not individual a and b calls). In this case, the complex call does guarantee that a runs and completes before starting b."
Kotlin supports the concept of 閳ユ竾unction literals with receivers閳? It enables the access on visible methods and properties of a receiver of a lambda in its body without any specific qualifiers. This is very similar to extension functions in which it閳ユ獨 also possible to access visible members of the receiver object inside the extension. 
"As you can see, such a function literal with receiver is taken as the argument block here. This block is simply executed and the receiver (which is an instance of T) is returned. In action this looks as follows:"
"We instantiate an object of Bar and call apply on it. The instance of Bar becomes the 閳ユ笧eceiver閳? The block, passed as an argument in {}(lambda expression) does not need to use additional qualifiers to access and modify the shown visible properties color and text."
"Using features of Kotlin coroutines, I would use a Flow in this case, particularly MutableSharedFlow. It is thread-safe and uses principles of queue. For example in this case it would look like the following:"
Fortunately the @Insert aonnotated functions do cater for retrieval of the value and returns it as a Long (if inserting a single object) or as an array of Longs when inserting an array/list of objects.
"I haven't debugged this, but if you remove your overuse of MutableLists and vars, and simplify your LiveData, you will likely eliminate your bug. At the very least, it will help you track down the problem."
"On a side note, all Kotlin extension functions that require knowing the charset already default to UTF-8, so if you require a different encoding you need to adjust the code above in calls to include encoding for reader(charset) or bufferedReader(charset)."
"I'm not sure removing the JRE is the best solution since you may need the JRE for other things, but I have not noticed any ill effects. Also, it appears I already had a JDK installed which may not be true for all Mac users."
"This will make the compiler generate the getter with another JVM name (the one specified in the annotation), thus avoiding the conflict, but making accessing it from Java less intuitive (especially since there will be two similar functions). In Kotlin, you will still be able to use the property with its original name context."
"In Java you're forced to put all static field and method declarations in a class and often you even have to create a class just for that purpose. Coming to Kotlin, many users look for the equivalent facility out of habit and end up overusing companion objects."
Kotlin completely decouples the notions of a file and a class. You can declare any number of public classes in the same file. You can also declare private top-level functions and variables and they'll be accessible only to the classes within the same file. This is a great way to organize closely associated code and data.
"Compared to top-level declarations, the syntax of companion objects is quite unwieldy. You should use them only when you specifically want to associate some public static code or data with a class and want your users to qualify access to it with the class's name. The use cases for this are quite rare and in most cases the top-level declarations are more natural."
"Finally, sometimes the concern of the generated bytecode matters. If, for whatever reason, you have to produce a Java class with Kotlin code such that the class has a static member, you must resort to a companion object and a special annotation."
"Kotlin coroutines can and should be used in production. That was the chief reason to officially release them in Kotlin 1.1. Having released them, the JetBrains team had committed to maintain backwards compatibility with respect to any changes that are introduced to them in the minor releases as they evolve, while allowing people to safely try them in complex production applications."
"In short, the difference between 閳ユ竼xperimental閳?and 閳ユ笜ormal閳?features, is that for normal Kotlin features new stuff cannot be added in minor updates, because there is a ""full compatibility"" guarantee, while for experimental features new stuff can be added, but nothing can be removed (because of the backwards compatibility guarantee)."
"Experimental coroutines use a separate kotlin.coroutines.experimental package name, so that when coroutines design is finalized and they move to kotlin.coroutines package, old compiled code will not break, but will  continue to work via a separate support library."
"The current version of kotlinx.coroutines is designed for production use. It is pretty well covered with tests, lots of things are already optimized, all the changes are made considering the issues of backwards compatibility with previously compiled code. It certainly does serve as a test-bed for various coroutine-based things, so there are some parts that are clearly marked as ""work in progress"" or ""unstable"" in the documentation of the corresponding functions and classes. However, by default, all the public APIs in kotlinx.coroutines are considered to be stable and are being evolved, if needed, with appropriate migration aids."
"kotlin-stdlib-jre[7/8] was deprecated a while ago, and has since been removed. The deprecation note was kept until 1.2.71, which was the last version to release those artifacts. The official deprecation notice can be found here. Using any of the deprecated versions (before it was removed) should also produce a warning in (at least) Android Studio and IntelliJ. "
Sometimes there are cases where you have mutating state that still needs to break or continue and is hard to do in a functional model.  You can make it work using more complex functions like fold and reduce combined with the filter and takeWhile functions but sometimes that is harder to grok.  Therefore if you really want that exact behavior you can use return from lambda expression which mimics a continue or break depending on your usage.
Coroutines are a completely separate thing from any scheduling policy that you describe. A coroutine is basically a call chain of suspend funs. Suspension is totally under your control: you just have to call suspendCoroutine. You'll get a callback object so you can call its resume method and get back to where you suspended.
"Kotlin has no need to stop any threads in order to suspend a coroutine. In fact, the main point of coroutines is that threads don't get started or stopped. The thread's top-level loop will go on and pick another runnable to run."
"@Suppress(""NON_PUBLIC_CALL_FROM_PUBLIC_INLINE"") is a band-aid workaround in the lack of @PublishedApi based on suppressing an error and therefore isn't recommended. With the introduction of @PublishedApi this suppression is going to be cleaned from the standard library."
"Generally, avoid using @param and @return tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use @param and @return only when a lengthy description is required which doesn't fit into the flow of the main text."
"I was using the jackson method, but turns out the performance of this is terrible on Android for first serialization (github issue here). And its dramatically worse for older android versions, (see benchmarks here)"
"SharedFlow/StateFlow is a hot flow, and, as described in the docs, A shared flow is called hot because its active instance exists independently of the presence of collectors. It means the scope that launches the collection of your flow won't complete by itself."
"To solve this issue, you need to cancel the scope in which collect is called, and as the scope of your test is the test itself, it's not ok to cancel the test, so what you need is to launch it in a different job."
"Even if Kotlin exposes a @JvmSynthetic annotation that is able to ""force"" the creation of synthetic methods, I advice to not using it in normal ""user"" code. Synthetic methods are low-level tricks made by the compiler, and we should never rely on such things in everyday code. I think it's there to support other parts of the standard library, but you should ask the JetBrains guys directly if you're curious (try on the official Kotlin Discussion Forum)"
"A StringBuilder is used as the receiver and apply is invoked on it. The block, passed as an argument in {}(lambda expression), does not need to use additional qualifiers and simply calls append, a visible method of StringBuilder multiple times."
"using lateinit, you are saying that you absolutely will make sure that an instance of that variable is created somewhere (otherwise, your application will throw an exception if a lateinit has not been initialized) and then that variable also will not be null throughout the rest of your project, compared to using null, it means that this object potentially could be null somewhere in your code for the rest of the project and you will have to deal with nullability throughout. "
"The lateinit keyword stands for late initialization. Lateinit comes very handy when a non-null initializer cannot be supplied in the constructor, but the developer is certain that the variable will not be null when accessing it, thus avoiding null checks when referencing it later."
"Unlike many languages, Kotlin distinguishes between mutable and immutable collections (lists, sets, maps, etc). Precise control over exactly when collections can be edited is useful for eliminating bugs, and for designing good APIs."
"The open annotation on a class is the opposite of Java's final: it allows others to inherit from this class. By default, all classes in Kotlin are final, which corresponds to Effective Java, Item 17: Design and document for inheritance or else prohibit it."
"TL;DR: never in business code (prefer custom sealed classes), but you can consider Result if you build a framework that must relay all kinds of errors through a different way than the exception mechanism (e.g. kotlinx.coroutines's implementation)."
"The Result class is designed to capture generic failures of Kotlin functions for their latter processing and should be used in general-purpose API like futures, etc, that deal with invocation of Kotlin code blocks and must be able to represent both a successful and a failed result of execution. The Result class is not designed to represent domain-specific error conditions."
"According to the Java documentation, the Error class ""indicates serious problems that a reasonable application should not try to catch"". There are some very special cases where you might want to try to recover from error, but that is quite exceptional (pun intended)."
"Sometimes it might still be useful to catch all exceptions (including these ones) around an area of code, and recover with a high level replacement for the whole failed operation (usually in framework code, but sometimes in business code too). This will probably be done with some try-catch(Exception), though, but Result will not be involved here because the point of such code would be to delimit with try-catch the high-level operation that can be replaced. Low-level code will not return Result because it doesn't know whether there are higher level operations that can be replaced with something in case of programming errors, or if it should just bubble up."
When generating a synthetic property for a Java getter/setter pair Kotlin first looks for a getter. The getter is enough to create a synthetic property with a type of the getter. On the other hand the property will not be created if only a setter presents.
"When a setter comes into play property creation becomes more difficult. The reason is that the getter and the setter may have different type. Moreover, the getter and/or the setter may be overridden in a subclass."
"First of all, the Kotlin Annotation processing tool (kapt) uses the Java compiler to run annotation processors. If your project contains any Java classes, kapt takes care of them by design. Kotlinlang recommends using kapt incase you used annotationProcessor from the Android Support before."
"I took an Int type and then tried to cast it as a Double by saying num as Double <...> However, this failed, saying that Int cannot be cast to Double. I am assuming this is because it is built off the Integer class rather than the raw int data type. "
"Whenever we want rather structural than referential equality, we can override equals, which is never done by default for normal classes, as you suggested. In Kotlin, we can use data class, for which the compiler automatically creates an implementation based on the constructor properties (read here)."
Please remember to always override hashCode if you override equals (and vice versa) manually and stick to the very strict contracts of both methods. Kotlin's compiler-generated implementations do satisfy the contract.
"But why the second one works? Because the Kotlin Int type corresponds to the Java int type. The two variables compared in the second example are primitive type values, not objects. Therefore, for them the reference equality is exactly the same as regular equality."
"We have made the strategy for generating pure fields (as opposed to get/set pairs) more predictable: from now on only properties annotated as @JvmField, lateinit or const are exposed as fields to Java clients. Older versions used heuristics and created static fields in objects unconditionally, which is against our initial design goal of having binary-compatibility-friendly APIs by default."
"This is an example of Unstructured Concurrency where it is not guaranteed that child coroutine would complete before returning. Thus, caller/parent coroutine would get wrong value returned by child coroutine. Even, when child coroutine has returned already, child coroutine may be running (in Active state) in the background which may lead to Memory Leaks in certain cases."
"There's no way to call Kotlin inline functions with reified type parameters from Java because they must be transformed and inlined at the call sites (in your case, T should be substituted with the actual type at each call site, but there's much more compiler logic for inline functions than just this), and the Java compiler is, expectedly, completely unaware of that."
"Awaits for completion of the task without blocking a thread.
  This suspending function is cancellable.
  If the Job of the current coroutine is cancelled or completed while this suspending function is waiting, this function stops waiting for the completion stage and immediately resumes with CancellationException."
"If you need to inspect Kotlin-specific stuff which is not exposed via the reflection API, or you're just generally curious what else is stored in that annotation, you can take a look at the implementation of kotlinx.reflect.lite. It's a light-weight library, the core of which is the protobuf-generated schema parser. There's not much supported there at the moment, but there are schemas available
which you can use to read any other data you need."
readMapKeyElement'
"Since delay is a suspendable function, and since we're using the Default dispatcher that is backed by a thread pool, lines 1, 2 and 3 may each execute on a different thread. Therefore your question about happen-before guarantees applies equally to this example. On the other hand, in this case it is (I would hope) completely obvious that the behavior of this code is consistent with the principles of sequential execution."
"Even though a coroutine in Kotlin can execute on multiple threads, it is just like a thread from a standpoint of mutable state. No two actions in the same coroutine can be concurrent."
"You need to have an empty constructor, all properties must be mutable (var) and you have to append field: in front of the @Element-Annotation. @JvmOverloads combined with default values will create the empty constructor for you as well as all other constructor variations."
"This way, you can observe for changes made in Firebase (and therefore be notified of future changes made to your values) using LiveData, rather than only execute a single fetch and then not be aware of changes made elsewhere to the same data."
"In the with(...) { ... } block, c becomes the implicit receiver, thus allowing you to use it as a dispatch receiver in C member extensions. This would work with any other function that uses functional types with receivers: apply, run, use etc."
In the case of calling Java code you are benefitting from SAM conversion for single method interfaces written in Java.  Then when you port the interface to Kotlin it does not allow this yet (Kotlin currently assumes you would use function references and lambdas instead of a single method interface).
"Since this is a Kotin interface, you cannot use the SAM conversion to a Lambda so that is why the other answer previously provided does not work.  If this was a Java interface, you could do that.  You can track SAM conversions for Kotlin interfaces in KT-7770."
"If you wanted this code to be more idiomatic Kotlin you would want function references or lambdas instead of interfaces, and you should just do that instead of relying on SAM conversion.  You can read more about that in Higher-Order Functions and Lambdas.  This is outside the scope of your question to go into more detail."
"Therefore as mentioned in another answer by @joakim, you must pass in a instance of a class that implements this interface.  This is called an Object Expression and looks like:"
Or realistically you should change your Kotlin port of the code to accept a reference to a function so that a lambda can be passed in directly.  That would be more idiomatic and you would be able to call it as you were originally attempting.
"In general, List<T> implementation may be a mutable list (e.g. ArrayList<T>), but if you pass it as a List<T>, no mutating functions will be exposed without casting. Such a list reference is called read-only, stating that the list is not meant to be changed. This is immutability through interfaces which was chosen as the approach to immutability for Kotlin stdlib."
One possible strategy is to use a Channel to join the launched jobs in order. You need to launch the jobs lazily so they don't start until join is called on them. trySend always succeeds when the Channel has unlimited capacity. You need to use trySend so it can be called from outside a coroutine.
"In the case of your code, this will also be triggered at startup, because when you change the anchors after onSizeChanged, this also starts the animation. But you can check if the value has been changed, so it's not a big problem."
When you call items.itemCount it gives you the size of itemSnapshotList which is initialized with an emptyList in the beginning. Think of the paging items as a state instead of an event which is fired. A state has always some value associated with it.
"In the majority of mature Kotlin code, you will find one of these patterns below.  The approach using Property Delegates takes advantage of the power of Kotlin to produce the smallest code."
"If you cannot trust in the performance of that hash lookup inside the logging system, you can get similar behavior to your Java code by using a companion object which can hold an instance and feel like a static to you."
"More on companion objects here: Companion Objects   ... Also note that in the sample above MyClass::class.java gets the instance of type Class<MyClass> for the logger, whereas this.javaClass would get the instance of type Class<MyClass.Companion>."
"But, there is really no reason to avoid calling and getting a logger at the instance level.   The idiomatic Java way you mentioned is outdated and based on fear of performance, whereas the logger per class is already cached by almost any reasonable logging system on the planet.   Just create a member to hold the logger object."
"Another approach, which is suggested by @Jire in another answer, is to create a property delegate, which you can then use to do the logic uniformly in any other class that you want.  There is a simpler way to do this since Kotlin provides a Lazy delegate already, we can just wrap it in a function.  One trick here is that if we want to know the type of the class currently using the delegate, we make it an extension function on any class:"
This code also makes sure that if you use it in a Companion Object that the logger name will be the same as if you used it on the class itself.  Now you can simply:
"You can't create arbitrary tuples in Kotlin, instead, you can use data classes. One option is using the built in Pair and Triple classes that are generic and can hold two or three values, respectively. You can use these combined with destructuring declarations like this:"
This code starts a bunch of coroutines and then sleeps so you have time to analyze the heap with a monitoring tool like VisualVM. I created the specialized classes JobList and ContinuationList because this makes it easier to analyze the heap dump.
"Yes, async-await takes about twice as long as withContext, but it's still just a microsecond. You'd have to launch them in a tight loop, doing almost nothing besides, for that to become ""a problem"" in your app."
"The cost of async-await is exactly 140 bytes higher than withContext, the number we got as the memory weight of one coroutine. This is just a fraction of the complete cost of setting up the CommonPool context."
"If performance/memory impact was the only criterion to decide between withContext and async-await, the conclusion would have to be that there's no relevant difference between them in 99% of real use cases."
I'm not sure there can be some strict rules on which function to choose. Usually you use apply when you need to do something with an object and return it. And when you need to perform some operations on an object and return some other object you can use either with or run. I  prefer run because it's more readable in my opinion but it's a matter of taste.
You can write extension functions for Kotlin that do an in place mutable iteration for any MutableList implementation.  These inline functions will perform as fast as any custom use of the iterator and is inlined for performance.  Perfect for Android or anywhere.
"In fact, the latter is more precise, because the actual value that foo evaluates to can be an instance of not Foo itself but one of its subtypes (and it's exactly what's denoted by the covariant out Foo)."
"If you need to run works in parallel then you can use coroutineScope or async coroutine builder functions. However, in your case you don't have more than a request and so it could be sequantial. As mentioned in previous answer you can use withContext. Here is the small explaination from docs:"
"Think of suspend functions as a way to use a function that takes a callback, but doesn't require you to to pass that callback into it. Instead, the callback code is everything under the suspend function call."
"Suspend functions should never be expected to block. If they do, they have been composed incorrectly. Any blocking code in a suspend function should be wrapped in something that backgrounds it, like withContext or suspendCancellableCoroutine (which is lower level because it works directly with the coroutine continuation)."
IntelliJ inspection that looks for blocking calls inside suspendable functions isn't powerful enough to see through a level of indirection between Dispatchers.IO and its usage in withContext. Here's a minimal reproducer of the issue:
The fact that it leverages the properties of a single-threaded context can be seen as a limitation of the first approach: it doesn't generalize to threadpool-based contexts. We can avoid this limitation by relying on the async-await mechanism:
"This annotation was added in the last moment before release, so we hadn't time to validate the design and decided to keep it internal for a while. There are good chances we make it public later."
"Notice, that the property's get method has a parameter thisRef. I require that it inherits from CloseableDelegateHost which will close any registered Closeables when it is closed. To simplify the implementation I delegate this interface to a simple list-based implementation."
But that only works because the object already is a Float; we just have to tell the compiler.聽 That wouldn't work for another numeric type; the following would give a ClassCastException:
"Some of the confusion may come because languages such as C and Java have been fairly lax about numeric types, and perform silent conversions in many cases.聽 That can be quite convenient; but it can also lead to subtle bugs.聽 For most developers, low-level bit-twiddling and calculation is less important than it was 40 or even 20 years ago, and so Kotlin moves some of the numeric special cases into the standard library, and requires explicit conversions, bringing extra safety."
"In case anyone is still looking for a solution, adding in a gradle task to copy the cases from the tmp directory into the directory that the coverage output looks in helps with this issue as a workaround."
"It can help to find both of the directories in your project manually before trying to point to them using gradle, to make sure that you're pointing to the right place (flavours will change the directories that you need to point to)"
"Naming a function same to a class is generally avoided in stdlib, too. Given SomeClass, in stdlib a preferred naming style for factory functions is someClassOf, someClassBy or whatever explains the semantics of the function best. The examples:"
"Which means you need to make your box focused, not just focusable. To do this you need a FocusRequester, in my example I'm asking focus when view renders. Check out more in this article"
"Also note that this feature works only for Java interop; since Kotlin
  has proper function types, automatic conversion of functions into
  implementations of Kotlin interfaces is unnecessary and therefore
  unsupported."
"As shown in the output you can see that also invoked println with the string value, so the also function may check for some condition or doing some computation before calling println.
You can rewrite your example using lambda expression (you will get the same output):"
"A small remark on terminology: init block is not actually a separate method. Instead, all init blocks together with member property initializers are compiled into the code of the constructor, so they should rather be considered a part of the constructor."
"Another way around the bug is to not collect the Stream.  You can stay lazy, and convert the Stream to a Kotlin Sequence or Iterator, here is an extension function for making a Sequence:"
Unfortunately the Files.list(...) that you originally used returns a Stream and doesn't give you the opportunity to use a traditional collection.  This change avoids that by starting with a function that returns an Array or collection.
"In most cases you can avoid Java 8 streams, and use native Kotlin stdlib functions and extensions to Java collections.  Kotlin does indeed use Java collections, via compile-time readonly and mutable interfaces.  But then it adds extension functions to provide more functionality.  Therefore you have the same performance but with many more capabilities. "
"It is a limitaion with jacoco plugin on kotlin. Since the classDirectories is not final, we cant go with the old way. We need to use the method classDirectories.setFrom to set the value."
"On the other hand, if you include Dagger-generated types in your kotlin code, you must have these available before kotlin code is compiled, which means you need Kotlin-aware annotation processor (KAPT)"
We have also moved the extension functions for Entity to be within Transaction so that these extension functions will not be seen nor callable without being in the context of this class.  This includes the methods of commit() and rollback() which can only be called now from within the class itself because they are now extension functions scoped within the class.  
"When Android wants to display the layout, it will recursively call the view.layout() function for each view in the view tree. Each Parent tells its children the constraints they might have (width/height) and ask them to view.measure() themselves. As a result, the view will store the measured values BASED on the constraints in designated members (MeasuredHeight/Width). Note that at this point view.getMeasuredHeight() will hold the value while view.getHeight() will still be invalid. view.getHeight() will only return a valid value once the view has an actual height in the UI hierarchy."
"Optimistically, this will end up succeeding. You can even make the custom handler introduce a delay or limit the number of times it returns true if you want to be extra defensive against infinite loops."
"Note that using SubcomposeLayout can affect performance - alternatively, you could do the same trick by storing the width in mutableStateOf - this would be more performant, but would also make the view flicker, since within one frame a view with an unconstrained width would be rendered (or empty space of the same size if you apply zero alpha)."
"NextActivity::class returns the KClass reference and the KClass has the property java and the Intent contructor signature is Intent(Context packageContext, Class cls) so the second parameter is Class type So the final answer would be this is not the extension this is just property."
It is just Kotlin compiler magic that it allows you to use it as if it was a part of the View class (notice that because of that you cannot access private/protected values from extension funtions). From java you must use it as it is.
