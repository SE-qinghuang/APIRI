"Also there is StructTag.Lookup() (was added in Go 1.7) which is ""like Get() but distinguishes the tag not containing the given key from the tag associating an empty string with the given key""."
"There is one caveat: Scanner will error with lines longer than 65536 characters.  If you know your line length is greater than 64K, use the Buffer() method to increase the scanner's capacity:"
"Also note that if your functions would actually be methods of some type, you could do it without a registry. Using reflection, you can get a method by name: Value.MethodByName(). You can also get / enumerate all methods without knowing their names using Value.NumMethod() and Value.Method() (also see Type.NumMethod() and Type.Method() if you need the name of the method or its parameter types)."
"Once you have the base path, you can get the full path by joining the base path and the relative path. You may use path.Join() or filepath.Join(), e.g.:"
StripPrefix will cut the /static/ and forward the modified request to the handler returned by http.FileServer() so it will see that the requested resource is
"The last missing piece is to make the io.Reader an io.ReadCloser, because bytes.Buffer does not have a Close() method. For this you may use ioutil.NopCloser() which wraps an io.Reader, and returns an io.ReadCloser, whose added Close() method will be a no-op (does nothing)."
So let's stick to the math/rand package. The rand.Rand uses a rand.Source as the source of random bits. rand.Source is an interface which specifies a Int63() int64 method: exactly and the only thing we needed and used in our latest solution.
"So the default source is slower than a Source that may be obtained by rand.NewSource(), because the default source has to provide safety under concurrent access / use, while rand.NewSource() does not offer this (and thus the Source returned by it is more likely to be faster)."
"Go 1.10 introduced strings.Builder. strings.Builder is a new type we can use to build contents of a string similar to bytes.Buffer. Internally it uses a []byte to build the content, and when we're done, we can obtain the final string value using its Builder.String() method. But what's cool in it is that it does this without performing the copy we just talked about above. It dares to do so because the byte slice used to build the string's content is not exposed, so it is guaranteed that no one can modify it unintentionally or maliciously to alter the produced ""immutable"" string."
"Do note that after creating a new strings.Buidler, we called its Builder.Grow() method, making sure it allocates a big-enough internal slice (to avoid reallocations as we add the random letters)."
"Go 1.7 added a rand.Read() function and a Rand.Read() method. We should be tempted to use these to read as many bytes as we need in one step, in order to achieve better performance."
"In case of Rectangle si.PrintArea() will actually call the method Shape.PrintArea() because you did not define a PrintArea() method for the Rectangle type (there is no method with receiver *Rectangle). And the implementation of Shape.PrintArea() method calls Shape.Area() not Rectangle.Area() - as discussed, Shape doesn't know about Rectangle. So you'll see"
"For example, if you want to parse the date/time in the Common Log Format, the format Apache uses for its log files, you would do so by passing the following string to time.Parse() as the layout argument."
"After you've retrieved the reflect.Value of the field by using Field(i) you can get a
interface value from it by calling Interface(). Said interface value then represents the 
value of the field."
"There is no function to convert the value of the field to a concrete type as there are,
as you may know, no generics in go. Thus, there is no function with the signature GetValue() T
with T being the type of that field (which changes of course, depending on the field)."
"Here, I'd rearrange things so the router doesn't need to include the routes: instead, each app package calls a router.Register() method. This is what the Gorilla web toolkit's mux package does. Your routes, database, and constants packages sound like low-level pieces that should be imported by your app code and not import it."
"Replace import-requiring object types in APIs with basic types and interfaces. Say two entities in your app have a many-to-many relationship like Users and Groups. If they live in different packages (a big 'if'), you can't have both u.Groups() returning a []group.Group and g.Users() returning []user.User because that requires the packages to import each other. "
"A single module can be used to build multiple executable binaries, but the func main() {...} entry point for each binary must be in its own package main, with each package main in a distinct directory."
"Here the method receiver is explicit. You only pass the method name (with the type it belongs to) to bar(), and when calling it, you have to pass the actual receiver: m(f)."
"If f is a value of type Foo, the expression f.A yields a function value of type func() with implicit receiver value f."
"Note that here the method receiver is implicit, it is saved with the function value passed to bar(), and so it is called without explicitly specifying it: m()."
"What must be kept in mind is that you can't read the results from the results slice without synchronization. And the waitgroup you used in your example is a sufficient synchronization. You are allowed to read the slice once wg.Wait() returns, because that can only happen after all worker goroutines called wg.Done(), and none of the worker goroutines modify the elements after they called wg.Done()."
"When would you want to refer to it? When you want to include a template in another e.g. using the {{template}} action, or when you want to execute a specific template using Template.ExecuteTemplate()."
"When you parse multiple templates at once, using Template.ParseFiles() or Template.ParseGlob(), then the templates will be named by the file names, and they will be associated automatically (the above mentioned functions return a single template.Template value, which holds all the parsed templates, associated). Doc of Template.ParseFiles() is clear on this:"
"Calling template.New() (function) creates a new template, associated to none. When calling Template.New() (method), the returned template will be associated with (all) the template(s) the method is called on."
"3. Also passing around or assigning array values will implicitly make a copy of the entire array, so it will be ""detached"" from the original value. If you pass a slice, it will still make a copy but just of the slice header, but the slice value (the header) will point to the same backing array. This may or may not be what you want. If you want to ""detach"" a slice from the ""original"" one, you have to explicitly copy the content e.g. with the builtin copy() function to a new slice."
"5. Related to the previous, the array length may also serve a documentation purpose. A type [4]byte properly documents that IPv4 has 4 bytes. An rgb variable of type [3]byte tells there are 1 byte for each color components. In some cases it is even taken out and is available, documented separately; for example in the crypto/md5 package: md5.Sum() returns a value of type [Size]byte where md5.Size is a constant being 16: the length of an MD5 checksum."
"Functions that have type parameters may use those to instantiate generic types, e.g. Getter[T]. Implementors must have exactly the Get() T method. For that to be valid, they are also generic and instantiated with the same type parameter:"
"You create a context capable of publishing cancelation signals with context.WithCancel() (parent context may be the one returned by context.Background()). This will return you a cancel() function which may be used to cancel (or more precisely signal the cancel intent) to the worker goroutines.
And in the worker goroutines you have to check if such intent has been initiated, by checking if the channel returned by Context.Done() is closed, easiest done by attempting to receive from it (which proceeds immediately if it is closed). And to do a non-blocking check (so you can continue if it is not closed), use the select statement with a default branch."
"Basically we just used the Done() channel of the context, so it seems we could just as easily (if not even easier) use a done channel instead of the Context, closing the channel to do what cancel() does in the above solution."
unsafe.SizeOf() and reflect.Type.Size() only return the size of the passed value without recursively traversing the data structure and adding sizes of pointed values.
"So either use this to parse the times, or use Time.Format() to produce your string representations where you can specify the layout, so you can use the same layout to parse the time strings."
Well I used reflect.ValueOf and then if it is a slice you can call Len() and Index() on the value to get the len of the slice and element at an index. I don't think you will be able to use the range operate to do this.
"So your best way to do it is more or less like your second example - through some sort of dependency injection using interfaces. i.e - A has a reference to some interface that does the actual work, say worker, that writes to a file or whatever. Then when instantiating B, you also replace A's worker with another worker (you can do it even without embedding A of course). The A just does something like myWorker.Work() without caring what worker it is."
You have to declare the slice type with type parameters you want to use for the Map() (or for any other) method:
"Simplest is to create a temporary file with the content you want to simulate as the input on os.Stdin. To create a temp file, use ioutil.TempFile(). Then write the content into it, and seek back to the beginning of the file. Now you can set it as os.Stdin and perform your tests. Don't forget to cleanup the temp file."
"Also note that you can refactor userInput() to not read from os.Stdin, but instead it could receive an io.Reader to read from. This would make it more robust and a lot easier to test."
"In your app you can simply pass os.Stdin to it, and in tests you can pass any io.Reader to it created / prepared in the tests, e.g. using strings.NewReader(), bytes.NewBuffer() or bytes.NewBufferString()."
"So the only guarantee you get is that the goroutine that runs my_func() will receive the value from channel c sent from main(). But once the value is received, the main function may continue but since there is no more statements after the send, it simply ends - along with the program. Whether the non-main goroutine will have time or chance to print it with fmt.Println() is not defined."
"And you can call Validate() on both: so the theoretical ""parent"" is not even ""constant"" for a given value of *B. This wouldn't be a deal-breaker, but: having a value of A, you can call the promoted method B.Validate() by writing a.Validate() which is OK, but you can also call it like a.B.Validate() - now this time you don't really have a value of A (arguable, but Validate() is called on a value of *B and not A), but finally you can also call b.Validate() - this time you definitely don't have a value of A."
"So image: you have a concrete value of *B and when its Validate() method is called, sometimes there is a parent, and sometimes there isn't. Then what would be the justification to have a parent at all?"
"Back to your example: for this Validate() method to validate something meaningful, it should (must) be passed to the Validate() method as a parameter - explicitly and not automatically."
You can simplify it a little though if you explicitly add a method to A which would call B.Validate() like this:
"There is no justification for a validator of the kind you imagine to be embedded in A, it should just be a field of A, or since there is no direct relation, it can be an ""independent"" validator. In both of these cases you may add a helper Validate() method to A if you would like to simplify validation."
"There is no tag in the encoding/json package that sets a field to ""required"". You will either have to write your own MarshalJSON() method, or do a post check for missing fields."
Here a Human is a Walker and a Dog is a Walker. Why? Because they both.. well... Walk. They both implement the Walk () string function. So this is why you can execute MakeWalk on them.
"rune is a type in Go. It's just an alias for int32, but it's usually used to represent Unicode points. rune() isn't a function, it's syntax for type conversion into rune. Conversions in Go always have the syntax type() which might make them look like functions. "
"Care must be taken when the task uses other channel operations, as they may block in a nondeterministic way. Those selects should include the ctx.Done() channel too:"
"Also be careful, because if the above receive from someChannel never blocks there is no guarantee a cancellation is properly handled, because if multiple communications can proceed in a select, one is chosen randomly (and there's no guarantee the <-ctx.Done() is ever chosen). In such case you may combine the above 2: first do a non-blocking check for cancellation, then use a select with your channel operations and the cancel monitoring."
Move the rand.Seed(time.Now().UTC().UnixNano()) line from the randInt function to the start of the main and everything will be faster. And lose the .UTC() call since:
"We can already see some repetition in the code above: when making both Cat and Dog say something. Can we handle both as the same kind of entity, as animal? Not really. Sure we could handle both as interface{}, but if we do so, we can't call their Say() method because a value of type interface{} does not define any methods."
There is some similarity in both of the above types: both have a method Say() with the same signature (parameters and result types). We can capture this with an interface:
"The important part is that we could handle both Cat and Dog as the same kind (an interface type), and work with them / use them. If you were  quickly on to create additional types with a Say() method, they could line up beside Cat and Dog:"
"You can call this function with a value of Cat, Dog, Horse or any other type not known until now, that has a Say() method. Cool."
Your program will exit when the main() function finishes.  This is likely to happen before your goroutine has time to run and print its output.
"The type that implements the HTTP server is http.Server. If you don't create an http.Server yourself e.g. because you call the http.ListenAndServe() function, that creates an http.Server under the hood for you:"
"So if you want to tweek / customize the HTTP server, then create one yourself and call its Server.ListenAndServe() method yourself. http.Server is a struct, its zero value is a valid configuration. See its doc what fields it has and so what you can tweak / configure."
"Also note that you can even do the rate-limiting in a single place, without using middlewares. Create a ""main handler"", and pass that to http.ListenAndServe() (or Server.ListenAndServe()). In this main handler do the rate limiting (e.g. using a buffered channel as mentioned above), and simply forward the call to the http.ServeMux you're using."
Here's a simple example which uses http.ListenAndServe() and the default  multiplexer of the http package (http.DefaultServeMux) for demonstration. It limits concurrent requests to 2:
"You can first create a new, undefined template with template.New(), and besides the template.ParseFiles() function, the template.Template type (returned by New()) also has a Template.ParseFiles() method, you can call that."
"f is a named type, but the parameter type of ff() is func(rune) rune which is unnamed, so the assignment is allowed."
The error cannot use type []byte as type *[]byte in argument to sliceArr() comes from a typo which you haven't posted (you tried to pass a slice and not a pointer to a slice to sliceArr()).
Also note that your task could be achieved by requiring only a (non pointer) slice as the parameter type and returning the new slice value - which of course must be assigned at the caller (a good example for this is the builtin append() function).
"There is a constant Huge in the source code (and will be in the package object), but it won't appear in your executable. Instead a function call to fmt.Println() will be recorded with a value passed to it, whose type will be float64. So in the executable only a float64 value being 10.0 will be recorded. There is no sign of any number being 1e1000 in the executable."
You may declare the internal map like m map[Key]*valueWrapper and so in Set() you can change the next field without having to assign a new valueWrapper.
"The approach with linked-list in value-wrapper can easily be extended to support fast element removal even if the map is big, if you also add the prev field to the valueWrapper struct. So if you need to remove an element, you can super-fast find the wrapper (O(1)), update the prev and next wrappers (to point to each other), and perform a simple delete() operation, it's O(1)."
"Yes, there is. You are calling mgo.Dial() before executing each query. mgo.Dial() has to connect to the MongoDB server every time, which you close right after the query. The connection may very likely take hundreds of milliseconds to estabilish, including authentication, allocating resources (both at server and client side), etc. This is very wasteful."
"Create a global session variable, connect on startup once (using e.g. a package init() function), and use that session (or a copy / clone of it, obtained by Session.Copy() or Session.Clone()).
For example:"
"Waitgroups panic if the counter falls below zero. The counter starts at zero, each Done() is a -1 and each Add() depends on the parameter. So, to ensure that the counter never drops below and avoid panics, you need the Add() to be guaranteed to come before the Done()."
"The memory model states that all statements in a single goroutine appear to be executed in the same order as they are written. It is possible that they won't actually be in that order, but the outcome will be as if it was. It is also guaranteed that a goroutine doesn't run until after the go statement that calls it. Since the Add() occurs before the go statement and the go statement occurs before the Done(), we know the Add() occurs before the Done()."
"If you were to have the go statement come before the Add(), the program may operate correctly. However, it would be a race condition because it would not be guaranteed. "
"As demonstrated in my example, I've defined a method, Bar(), on a non-pointer receiver, and if you'll try to assign a value to the receiver that will succeed but won't affect the caller because the receiver閳ユ攣s everything in Go閳ユ攬as been passed by value (so that integer has just been copied)."
"Gorilla's handlers.CORS() will set sane defaults to get the basics of CORS working for you; however, you can (and maybe should) take control in a more functional manner."
"If you use time.Since() to get the elapsed time since a time.Time value, or when you calculate the difference between 2 time.Time values using the Time.Sub() method, the result is a time.Duration which loses the time context (as Duration is just the time difference in nanoseconds). This means you cannot accurately and  unambiguously calculate the difference in years, months, etc. from a Duration value."
"The difference calculation will only give correct result if both of the time values we pass in are in the same time zone (time.Location). We incorporate a check into our function: if this is not the case, we ""convert"" one of the time value to be in the same location as the other using the Time.In() method:"
"Because fmt.Println() tries to print the content recursively, and since the 2nd element is a slice pointing to the same array of the the slice being printed, it runs into an infinite loop."
"If you want to create some kind of framework where you call functions passing values to ""named"" parameters (e.g. mapping incoming API params to Go function/method params), you may use a struct because using the reflect package you can get the named fields (e.g. Value.FieldByName() and Type.FieldByName()), or you may use a map. See this related question: Initialize function fields"
"Addressing your concerns regarding returning the tree pointer: there's nothing wrong with that. Take a look at the builtin function append(): it appends elements to a slice and returns the modified slice. You (the caller) have to assign the returned slice to your slice variable, because append() may modify the slice by allocating a new one if the additional elements do not fit into the original (and since append() takes a non-pointer, the modified value must be returned)."
"This is much easier: The function http.ServeFile() is capable of sending the content of one file to the specified response. You still need to create a function or handler to use it, but it does the rest for you:"
"If you need to serve multiple static files, this is where FileServer() function comes handy which returns you a Handler which automatically serves files from your local file system that are descendants of the root folder you specify."
"If we're talking about ""coding"" time (source code writing / generating), then it's possible without creating / allocating a variable of the given type and calling reflect.TypeOf() and passing the variable."
"You may start from the pointer to the type, and use a typed nil pointer value without allocation, and you can navigate from its reflect.Type descriptor to the descriptor of the base type (or element type) of the pointer using Type.Elem()."
"The reason for the changed behavior is because &s and &ss escape to heap: they are directly passed to fmt.Println(), so the compiler changed how (where) they are stored, and with that, so did their address."
"In the case of go-sqlite3, the underscore import is used for the side-effect of registering the sqlite3 driver as a database driver in the init() function, without importing any other functions:"
"You can use the Time.String() method to convert a time.Time to a string. This uses the format string ""2006-01-02 15:04:05.999999999 -0700 MST""."
"If you need other custom format, you can use Time.Format(). For example to get the timestamp in the format of yyyy-MM-dd HH:mm:ss use the format string ""2006-01-02 15:04:05""."
"Also note that using Time.Format(), as the layout string you always have to pass the same time 閳ユ彿alled the reference time锟?formatted in a way you want the result to be formatted. This is documented at Time.Format():"
"It's known and used to a lesser extent, but it's also handy that you can ""truly"" embed a mutex in a struct, and you can call Lock() and Unlock() as if they would be part of the struct itself. It looks like this:"
"A very similar issue is when you define the String() string method for custom text representation for the fmt package, and you want to use the default string representation which you modify. Read more about it here: The difference between t and *t"
"You can however, maintain a global map[string]reflect.Type manually. For example by initializing this map in the init() function of your packages which defines such discover-able types. This will also tell the compiler that you are using the types. Afterwards, you can use this map to look up the reflect.Type of the type you want to create and use reflect.New to get a pointer to a new object of that type (stored as a reflect.Value). You can extract the object into an interface with something like this:"
Elem() will de-reference the pointer and Interface() will return the reflected value as an interface{}. See The Laws of Reflection for further details.
PS: There might be a better way to structure your program which doesn't even require reflection and which let the compiler catch more errors. Have you considered using a factory method for example? An other easy solution might be to maintain a map[string]func() interface{} of functions which can be invoked to create a new object with that name.
"The heap is freed, you can check this using runtime.ReadMemStats(),
  but the processes virtual address space does not shrink -- ie, your 
  program will not return memory to the operating system. On Unix based 
  platforms we use a system call to tell the operating system that it 
  can reclaim unused parts of the heap, this facility is not available 
  on Windows platforms."
(Edit: Note that you can force garbage collection with runtime.GC() though obviously you need to be careful how often you use it; you may be able to sync it with sudden downward spikes in connections).
"With Decoder.Decode(), we may read (unmarshal) a single value without consuming and unmarshaling the complete stream. This is cool, but your input is a ""single"" JSON object, not a series of JSON objects, which means a call to Decoder.Decode() would attempt to unmarshal the complete JSON object with all items (large objects)."
"What we want is partially, on-the-fly processing of a single JSON object. For this, we may use Decoder.Token() which parses (advances) only the next subsequent token in the JSON input stream and returns it. This is called event-driven parsing."
"So when you write .Name, that means that the value where dot is pointing currently, you want to refer to its field or method or key called Name. For example if you pass a struct, at the beginning of your template .Name will denote the struct field Name if it exists, or its method named Name()."
"You can get the name of a named type using the Type.Name() method, which ""returns an empty string for unnamed types"":"
"You may use Type.PkgPath() to get a named type's package path, which ""if the type was predeclared (string, error) or unnamed (*T, struct{}, []int), the package path will be the empty string"":"
"So you have 2 tools available to you: Type.Name() to tell if the type is a named type, and Type.PkgPath() to tell if the type is not predeclared and is a named type."
"What can you do in such cases? You may use Type.Elem() to get the type's element type, if type's Kind is Array, Chan, Map, Ptr, or Slice (else Type.Elem() panics):"
"Type.PkgPath() can be used to ""filter out"" predeclared and unnamed types. If PkgPath() returns a non-empty string, you can be sure it's a ""custom"" type. If it returns an empty string, it still may be an unnamed type (in which case Type.Name() returns """") constructed from a ""custom"" type; for that you may use Type.Elem() to see if it is constructed from a ""custom"" type, which may have to be applied recursively:"
"The value type of a map can be queried with the above mentioned Type.Elem() method, and the key type of a map can be queried with the Type.Key() method - we also have to check this in case of maps."
And you can register a function for the template (see template.Funcs()) to which you can pass the $index and it would return the date field of the previous element (at $index -1).
"This means when Test3.combo() is called from Test3.run() like c.combo(), a copy is made of c (which is of type Test3). The combo() method operates on a copy. It properly appends 2 numbers to Test3.all, but when this method returns, the copy is discarded."
"So when Test3.run() returns c.all, it returns an empty (nil) slice, because the slice to which Test3.combo() appended, was a field of a copy, and which has been discarded."
"Note the star * in the receiver: func (c *Test3) combo(). By adding it, you make the receiver a pointer, and so when combo() is called, it only receives a pointer to a value of type Test3, and it will modify the pointed value, the value that Test3.run() has, so when combo() returns, the changes are not lost."
You may check out the exact Javascript code how Gowut does it in its js.go file (look for the rerenderComp() Javascript function).
"Using this example Worker, the main goroutine can fetch the iteration using Worker.Iter(), and the worker itself can change / update the iteration using Worker.setIter() or Worker.incIter() at any time, without any additional synchronization. The synchronization is ensured by the proper use of Worker.iterMu."
"And the main app that also imports (the same) package filter, loads the plugin, looks up GetFilter(), calls it and also uses the returned Filter:"
"A nil slice will however json.Marshal() into ""null"" whereas an empty slice will marshal into ""[]"", as pointed out by  @farwayer."
As a commenter mentioned you can get Values from net/url which has an Encode method. You could do something like this (req.URL.Query() returns the existing url.Values)
"If you can't or don't want to change it to a pointer, you can still achieve what you want by implementing a custom Marshaler and Unmarshaler. If you do so, you can use the Time.IsZero() method to decide if a time.Time value is the zero value."
"Yes, with a simple refactoring. Create a zSomeFunc variable of function type, initialized with z.SomeFunc, and have your package call that instead of z.SomeFunc():"
"There is no memset support in the standard library, but we can make use of the built-in copy() which is highly optimized."
"We can set the first element manually, and start copying the already set part to the unset part using copy(); where the already set part gets bigger and bigger every time (doubles), so the number of iterations is log(n):"
"In case of small slices memsetRepeat() may be slower than memsetLoop() (but in case of small slices it doesn't really matter, it will run in an instant)."
The image package has a Decode() function which decodes and returns an Image from the specified io.Reader. Often it is unknown what type of image comes from the reader and so you can't use the decoder algorithm of a specific image format.
"In this case if we want the image decoding mechanism to be extensible, a registration is unavoidable. The cleanest to do this is in package init() functions which is triggered by specifying the blank identifier for the package name when importing."
"Note that this solution also gives you the possibility to use a specific implementation to decode an image, the concrete implementations also provide the Decode() function, for example png.Decode()."
Now this CustomLabel type looks much better performance-wise as the type in question: its size is still 0. And it is still possible to access the array's element type using Type.Elem() like in this example:
"You can register functions with the Template.Funcs() function, you may execute a named template with Template.ExecuteTemplate() and you may use a bytes.Buffer as the target (direct template execution result into a buffer)."
"The ""my-template"" template is executed by the registered function execTempl(), and the result is returned as a string, which is stored in the $var template variable, which then is simply added to the output, but you may use it to pass to other functions if you want to."
"Your content is accessible somewhere, somehow, you know how. Seek() is called to let you know what part (position) is required from your content, and Read() is called so you can populate the passed slice (to provide the actual content). Note that these methods may be called multiple times, so you have to keep track where you are in your content (source). If you choose to go down this path, please read the doc of the linked interfaces to make sure you meet the ""general contract"" of the interfaces to avoid surprise errors."
"But in the main package you still don't call subplay.A(), the size of the executable binary does not change: remains 5,370,935 bytes!"
"It is because every incoming request is routed to your HelloWorld() handler function, and the browser makes multiple calls under the hood, specifically to /favicon.ico."
"We now have the results, but in a slice of type []bson.Raw. But we want it in a slice of type []*User. This is where Collection.NewIter() comes handy. It can transform (unmarshal) a value of type []bson.Raw into any type we usually pass to Query.All() or Iter.All(). Good. Let's see it:"
"The manual way is quite lengthy; it can be made general and automated. This is where github.com/icza/minquery comes into the picture (disclosure: I'm the author). It provides a wrapper to configure and execute a MongoDB find command, allowing you to specify a cursor, and after executing the query, it gives you back the new cursor to be used to query the next batch of results. The wrapper is the MinQuery type which is very similar to mgo.Query but it supports specifying MongoDB's min via the MinQuery.Cursor() method."
"Note #1: When calling MinQuery.All(), you have to provide the names of the cursor fields, this will be used to build the cursor data (and ultimately the cursor string) from."
"Note #2: If you're retrieving partial results (by using MinQuery.Select()), you have to include all the fields that are part of the cursor (the index entry) even if you don't intend to use them directly, else MinQuery.All() will not have all the values of the cursor fields, and so it will not be able to create the proper cursor value."
"If t1 and t2 would also contain the same *Location pointer, they would be equal even if compared with the == operator. This can be ensured by calling Time.UTC() or Time.Local() method on them which returns a time.Time value where the same location pointer (*Location) is used. Or by using the Time.In() method which will set the specified location pointer (after the proper conversion), e.g.:"
"If you own (or you can modify) the package, best is to provide a Clone() method or function, or provide a SetIs() method for the type T. If a 3rd party package does not provide such functionality, there's nothing you can do about it."
"One thing you should be aware of is that strconv.Unquote() can only unquote strings that are in quotes (e.g. start and end with a quote char "" or a back quote char `),  so we have to manually append that."
"If the strings you want to unquote contain the escape sequence of a single rune (or you just want to unquote the first rune), you may use strconv.UnquoteChar(). This is how it looks like (note: no quoting of the input is needed in this case, like it was needed for strconv.Unquote()):"
"For each started sender goroutine we add 1 to the WaitGroup using WaitGroup.Add(). And each goroutine that is done sending the values can signal this by calling WaitGroup.Done(). Best to do this as a deferred statement, so if your goroutine would terminate abruptly (e.g. panics), WaitGroup.Done() would still be called, and would not leave other goroutines hanging (waiting for an absolution - a ""missing"" WaitGroup.Done() call that would never come...)."
"reflect.TypeOf() (and reflect.ValueOf()) expects an interface{}. Basically whatever value you pass to reflect.TypeOf(), if it's not already an interface value, it will be wrapped in an interface{} implicitly. If the passed value is already an interface value, then the concrete value stored in it will be passed as a interface{}."
"So if you pass a pointer to interface, this pointer will be wrapped in an interface{} value. You may use Type.Elem() to get the type descriptor of the ""pointed type"": that is, the element type of the pointer type, which will be the type descriptor of the interface type you're looking for."
"Keep in mind that init() is always called, regardless if there's main or not, so if you import a package that has an init function, it will be executed."
"Additionally, you can have multiple init() functions per package; they will be executed in the order they show up in the file (after all variables are initialized of course). If they span multiple files, they will be executed in lexical file name order (as pointed out by @benc):"
"It seems that init() functions are executed in lexical file name order. The Go spec says ""build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler"". It seems that go build works this way."
"It's easy to determine if the exit code was 0 or something else. In the first case, cmd.Wait() will return nil (unless there is another error while setting up the pipes)."
"I agree with Brainstorm's approach: assuming that you're passing a machine-friendly binary representation, use the encoding/binary library.  The OP suggests that binary.Write() might have some overhead.  Looking at the source for the implementation of Write(), I see that it does some runtime decisions for maximum flexibility."
"Right?  Write() takes in a very generic data third argument, and that's imposing some overhead as the Go runtime then is forced into encoding type information.  Since Write() is doing some runtime decisions here that you simply don't need in your situation, maybe you can just directly call the encoding functions and see if it performs better."
We can make it more pleasant to use by adding the brackets to the parameter names automatically in the log() function:
"Note that *bytes.Buffer does not have a Close() error method, so it doesn't implement the io.ReadCloser interface. Thus, we have to wrap our *bytes.Buffer values in calls to ioutil.NopCloser."
"However for your needs (detecting tab) C's getchar() is not suitable as it requires the user to hit enter. What you need is something like ncurses' getch()/ readline/ jLine as mentioned by @miku. With these, you actually wait for a single keystroke. "
"Also note that if some test functions mark themselves eligible for parallel execution using the T.Parallel() method, the go tool will reorder the tests to first run non-parallel tests, and then run parallel tests in parallel under certain circumstances (controlled by test flags like -p). You can see examples of this in this answer: Are tests executed in parallel in Go or one by one?"
"In your case in package init() or TestMain() you should check if your DB is initialized (there are test records inserted), and if not, insert the test records."
"So a string is a byte slice, which is the UTF-8 encoded bytes in case of a valid text. Assuming you want to store a valid text in your optional string (if you wouldn't, then you can just use a []byte instead which can have a nil value), you can choose a string value which represents an invalid UTF-8 byte sequence and thus you won't even have to make a compromise to exclude a valid text from the possible values. The shortest invalid UTF-8 byte sequence is 1 byte only, for example 0xff (there are more). Note: you can use the utf8.ValidString() function to tell if a string value is a valid text (valid UTF-8 encoded byte sequence)."
"Use sync.RWMutex instead of sync.Mutex, so that the getMe() may lock for reading only, so multiple concurrent readers would not block each other."
"unsafe.Sizeof() does not recursively go into data structures, it just reports the ""shallow"" size of the value passed. Quoting from its doc:"
"Go stores the UTF-8 encoded byte sequences of string values in memory. The builtin function len() reports the byte-length of a string, so
basically the memory required to store a string value in memory is:"
"An alternative but still imperfect way is to guard against concurrent Done() events (the ""wrong select"") after consuming the ticker event i.e."
The Scanner returned by bufio.NewScanner() reads whole lines and only returns something if a newline character is encountered (as defined by the bufio.ScanLines() function).
"If you have no guarantee that the child process prints newline characters but you still want to stream the output, you can't read whole lines. One solution is to read by words, or even read by characters (runes). You can achieve this by setting a different split function using the Scanner.Split() method:"
"Elements in a map have no fixed order. If you need to keep the order (e.g. insertion order), then use a slice (to remember the order) and a map (to tell if an element to be added is new). This is easiest with a helper add() function:"
"There is no filesystem ""root"" concept. The provided web server uses handlers to serve HTTP requests which are mapped to URLs. A handler is responsible to process an HTTP request and to setup and generate the response. A handler can be registered e.g. with the Handle() or HandleFunc() functions. The server can be started with the ListenAndServe() function."
"However, a static file server or ""filesystem"" functionality is provided, there is a FileServer() function in the http package which returns a Handler which serves static files. You can specify the ""root"" folder to serve static files from as a parameter of FileServer()."
"If you pass an absolute path to FileServer(), then there is no question what that means. If you provide a relative path, it is always interpreted in the context of the current or working directory. By default this is the folder you start the application from (the folder you're in when executing the go run ... command or the compiled executable binary)."
"It's not possible. The encoding/json package only handles the json key in struct tags. If the json key is listed multiple times (as in your example), the first occurrence will be used (this is implemented in StructTag.Get())."
"One way you could get around this is to assert that foo has the method test(), which would look something like this:"
"This simple getSize() function returns the size of a file specified by its name, returning the error if filesystem.Stat() fails (returns an error)."
"We need a mocked version of filesystem, mocked so that it does not actually interact with the filesystem, but returns sensible data when methods of filesystem are called (filesystem.Stat() in our case). To easiest mock filesystem (or any interface), we will embed filesystem in our mockedFS, so we ""inherit"" all its methods, and we will only need to mock what is actually used by the testable code. Note that calling other methods would result in runtime panic, as we won't really give a sensible, non-nil value to this embedded filesystem, but for the sake of tests it is not needed."
"Once we have the mocked types, we have to set them up. Since getSize() uses the global fs variable to interact with the filesystem, we need to assign a value of our mockedFS to this global fs variable. Before doing so it's recommended to save its old value, and properly restore the old value once we're done with the test: ""cleanup""."
"Since we fully want to test getSize() (including the error case), we armour our mockedFS with the ability to control whether it should return an error, and also the ability to tell it what to return in case we don't want any errors."
"c is of type car (non-pointer); since the car.fourWheels() method has a pointer receiver and because the receiver value is a non-pointer and is addressable, it is a shorthand for:"
"What you can do is work with the number as normal, but when you print it, round it to decimal places of your choice. The easiest is to use fmt.Printf(), and specify a format string using the verb %f including the precision:"
"In your example FooLinkerEntity and BarLinkerEntity are just decorators, so they don't need to embed (extend in OOP) Entity, and their implementations don't need to embed EntityImpl. However, since we want to use the Entity.Id() method, we need an Entity value, which may or may not be EntityImpl, but let's not restrict their implementation. Also we may choose to embed it or make it a ""regular"" struct field, it doesn't matter (both works):"
"If the FooBarEntityImpl does not need to know (does not use) the internals of the Entity, Foo and Bar implementations (EntityImpl, FooImpl and BarImpl in our cases), we may choose to embed only the interfaces and not the implementations (but in this case we can't call x.FooImpl.Id() because Foo does not implement Entity - that is an implementation detail which was our initial statement that we don't need / use it):"
Note that the factory function NewFooBarEntity() returns a value of interface type and not the implementation type (good practice to be followed).
"Also note that if the value of school contains special regexp characters, that might give you unexpected results or errors. So best is to quote it with e.g. using regexp.QuoteMeta():"
"The resulting slice contains os.DirEntry types, which provide the methods listed here. Here is a basic example that lists the name of everything in the current directory (folders are included but not specially marked - you can check if an item is a folder by using the IsDir() method):"
"new() is the only way to get a pointer to an
  unnamed integer or other basic type.  You can write ""p := new(int)"" but
  you can't write ""p := &int{0}"".  Other than that, it's a matter of
  preference."
I experienced this reliably. You need to set Req.Close to true (the defer on resp.Body.Close() syntax used in the examples is not enough). Like this:
"(Note that user.Current() is not implemented in the go playground (likely for security reasons), so I can't give an easily runnable example)."
"Let's assume you already have the font file loaded, and a c context configured (see the example how to do that). Then your addLabel() function could look like this:"
"This is how this addLabel() function can be used: the code below creates a new image, draws the ""Hello Go"" text on it and saves it in a file named hello-go.png:"
"Also note that the y coordinate given will be the bottom line of the text. So if you want to draw a line to the top left corner, you have to use x = 0 and y = 13 (13 is the height of this Face7x13 font). If you wish, you could build this into the addLabel() function by subtracting 13 from the y coordinate, so that the passed y coordinate would be the top coordinate at which the text will be drawn."
"Additionally, you could check in the server/handler whether you get a relative or absolute URL in the request by calling the IsAbs() method:"
"Update: Due to the above code using ==, it won't work for types that are not comparable. I believe that using reflect.DeepEqual() instead will make it work for all types:"
"When close(quit) is executed, the last statement of our main() function can proceed which means the main goroutine can return, so the program exits."
"If you don't want to block the main goroutine but you just don't want it to end, you may use a time.Sleep() with a sufficiently large duration. The max duration value is"
"It is expected that io.Reader implementations return this specific error value to signal end of input. So you can peacefully compare the error returned by Reader.Read() to io.EOF to tell if end of input is reached. You can be sure that if they occasionally return custom errors, they will never be equal to io.EOF, this is what errors.New() guarantees (because it returns a pointer to an unexported struct value)."
"Note that fork() has been invented at the time when no threads were used at all, and a process had always had just a single thread of execution in it, and hence forking it was safe. With Go, the situation is radically different as it heavily uses OS-level threads to power its goroutine scheduling."
"And now think about the problem further.  I'd say these days the only thing a direct call to fork(2) is useful for is ""best-effort asynchronous process state snapshotting""閳ユ敄he kind, say, Redis uses.  This technique relies on the fact the child process inherits all the memory data pages from its parent, but the OS uses copy-on-write technique to not really copy all that data, so the child can just sit there and save all the data structures to disk while its parent is chugging away modifying them in its own address space.  Every other conceivable use for fork() implies immediate exec(), and that's what exec.Command() et al is for, so why just not use it?"
On successful decoding image.Decode() (and also specific decoding functions like jpeg.Decode()) return a value of image.Image. image.Image is an interface which defines a read-only view of an image: it does not provide methods to change / draw on the image.
"image.Decode() however does not give you any guarantee that the returned image will be any of the image types defined in the image package, or even that the dynamic type of the image has a Set() method (it may, but no guarantee). Registered custom image decoders may return you an image.Image value being a custom implementation (meaning not an image type defined in the image package)."
"If the (dynamic type of the) image does have a Set() method, you may use type assertion and use its Set() method to draw on it. This is how it can be done:"
"If the image does not have a Set() method, you may choose to ""override its view"" by implementing a custom type which implements image.Image, but in its At(x, y int) color.Color method (which returns / supplies the colors of pixels) you return the new colors that you would set if the image would be changeable, and return the pixels of the original image where you would not change the image."
"If you have to change many pixels, it's not practical to include all in the At() method. For that we can extend our MyImg to have our Set() implementation which stores the pixels that we want to change. Example implementation:"
"The above code is just for demonstration. In ""real-life"" images Image.Bounds() may return a rectangle that does not start at (0;0) point, in which case some adjustment would be needed to make it work."
"Short answer: if you're using the database/sql package, your deferred Rows.Close() methods will properly close both of your Rows instances because Rows.Close() has pointer receiver and because DB.Query() returns a pointer (and so rows is a pointer). See reasoning and explanation below."
"Note that even though you now have a pointer receiver, you can still call your Add() method on non-pointer values if they are addressable, so for example the following also works:"
"And unfortunately there is no other way. If you pass a value of interface{} type, the json package implementation is free to choose a type of its choice, and it will choose map[string]interface{} for JSON objects, and []interface{} for JSON arrays. This is documented at json.Unmarshal():"
"If you know the type beforehand, create a value of that type, and pass that for unmarshaling. Whether your store this in an interface{} variable beforehand does not matter; if the passed value is suitable for unmarshaling, it will be used. Note that the passed value will be wrapped in an interface{} if not already of that type, as that is the parameter type of json.Unmarshal()."
"And since we're always reading numbers, we can create a highly optimized converter to get the number. We should avoid using Scanner.Text() which creates a string as we can obtain the number just from the raw bytes returned by Scanner.Bytes(). Scanner.Text() returns the same token as Scanner.Bytes() but it first converts to string which is obviously slower and generates ""garbage"" and work for the gc."
"This toInt() works because the []byte contains the UTF-8 encoded byte sequence of the string representation of the decimal format of the number, which contains only digits in the range of '0'..'9' whose UTF-8 encoded bytes are mapped one-to-one (one byte is used for one digit). The mapping from digit to byte is simply a shift: '0' -> 48, '1' -> 49 etc."
"The empty loop is usually never desired in Go and will, in most cases, indicate a bug in the program. If you do need it for whatever reason, you have to manually yield to the scheduler by calling runtime.Gosched() in every iteration."
"Setting GOMAXPROCS to a value > 1 was mentioned as a solution. While this will get rid of the immediate problem you observed, it will effectively move the problem to a different OS thread, if the scheduler decides to move the looping goroutine to its own OS thread that is. There is no guarantee of this, unless you call runtime.LockOSThread() at the start of the processevents function. Even then, I would still not rely on this approach to be a good solution. Simply calling runtime.Gosched() in the loop itself, will solve all the issues, regardless of which OS thread the goroutine is running in."
"In your first example addresses of the backing array(s) for your slices are only used inside the main() function, they don't escape to the heap. What you print is only the result of the comparison of the addresses. These are just bool values, they don't include the address values. So the compiler chooses to use the same address for the backing array of a and b."
"In your second example addresses of the backing arrays (more specifically addresses of some elements of the backing arrays) are used outside of the main() function, they are passed to and used inside the fmt.Println() function, because you are also printing these addresses."
"Note: If you are able to pass in a template.URL value directly to the template execution, you do not need to register and use a safeURL() custom function:"
"This is because the declaration ends after the closing bracket of the anonymous function, so inside of it you can't call f(). A workaround would be:"
"Now here the declaration of f ends at the closing parenthesis (of its type func()), so in the next line when we assign an anonymous function to it, it is valid to refer to f (to call the function value stored in the f variable) because it is now in scope. See related question: Define a recursive function within a function in Go"
"is a constant expression, it is evaluated exactly. Thus, writing fmt.Println(912 * 0.01) has the same effect as writing fmt.Println(9.12). When you pin 912 to float64, the other operand of the floating-point multiplication is implicitly pinned to float64, too. Thus, the expression float64(912) * 0.01 behaves like float64(912) * float64(0.01). 0.01 is not exactly representable in a float64, thus precision is lost in a different place than in the expression float64(912 * 0.01) which arises in the argument of fmt.Println() in your first example, explaining the different results."
"A method call x.m() is valid if the method set of (the type of) x contains m and the argument list can be assigned to the parameter list of m. If x is addressable and &x's method set contains m, x.m() is shorthand for (&x).m()."
"The compiler sees that Scale() has a pointer receiver and also that v is addressable (as it is a local variable), so v.Scale(10) will be interpreted as (&v).Scale(10)."
"reflect.ValueOf() is a function, think of it as the entry point to reflection. When you have a ""non-reflection"" value, such as a string or int, you can use reflect.ValueOf() to get a reflect.Value descriptor of it."
"Value.Elem() is a method of reflect.Value. So you can only use this if you already have a reflect.Value. You may use Value.Elem() to get the value (reflect.Value) pointed by the value wrapped by the original reflect.Value. Note that you may also use reflect.Indirect() for this. There's another ""use case"" for Value.Elem(), but it's more ""advanced"", we return to it at the end of the answer."
"We saw how Value.Elem() can be used to ""navigate"" when a pointer is wrapped in the reflect.Value. Doc of Value.Elem() says:"
"So if reflect.Value wraps an interface value, Value.Elem() may also be used to get the concrete value wrapped in that interface value."
"Basically whatever value you pass to reflect.ValueOf(), if it's not already an interface value, it will be wrapped in an interface{} implicitly. If the passed value is already an interface value, then the concrete value stored in it will be passed as a interface{}. This second ""use case"" surfaces if you pass a pointer to interface (which is otherwise very rare in Go!)."
"So if you pass a pointer to interface, this pointer will be wrapped in an interface{} value. You may use Value.Elem() to get the pointed value, which will be an interface value (not a concrete value), and using Value.Elem() again on this will give you the concrete value."
"There is no pollution of multiple logs, and all the details and context are preserved because we used errors.Wrap() which produces an error value which formats to a string which preserves the wrapped errors, recursively: the error stack."
"So when you call do(t), you're attempting to pass a type *T into something that expects a stringer, but T, pointer or not, just does not inherently have the a() string method in its type set."
"You have to ""inject"" some code into the function that is launched as a new goroutine: you have to call a deferred function in which you call recover(). This is the only way to recover from a panicing state. See related: Why does `defer recover()` not catch panics?"
"Note that launching an actual goroutine happens outside of wrap(). This gives the caller the option to decide if a new goroutine is required just by prefixing the wrap() call with go. Usually this approach is preferred in Go. This allows you to execute arbitrary functions by passing them to wrap(), and it will ""protect"" its execution (by recovering from panics, properly logging / reporting it) even if you do not wish to run it concurrently in a new goroutine. On the other hand if you'd move go inside wrap() it wouldn't even work anymore as the recover() call would not happen on the panicking goroutine."
"The problem with loop1() is that you store a function literal in the actions map that references the loop variable cmd. There is only one instance of this loop variable, so when after the loop you call the functions stored in the actions map, all will refer to this single loop variable (which is kept because the functions / closures still have a reference to it), but its value at the time of execution will be the last value set by the for loop, which is the last value in the cmds slice (that is, ""update"", so you'll see ""update"" printed 3 times)."
"Consider that constraints that embed comparable are also valid for map keys, so if you really need the method isList() in the function body, you can define a constraint like this, and have your lists-that-are-map-key structs implement that, instead of declaring an interface field:"
"You may trigger a gc to free unused objects with runtime.GC() and you may urge your Go runtime to release memory back to OS with debug.FreeOSMemory(), but all these are just fire fighting. A well-written Go app should never have to call these."
"Create / change your processing units not to operate on byte slices but on io.Readers, so you don't need to read all content into memory, you can just pass resp.Body on. Note that even if multiple units have to read / inspect the body, it is still possible to only read and process it once, and not keep it in memory. Means may be io.Pipe(), io.TeeReader() or custom solutions."
"Once a value is received from c1, in the next iteration executing select again a new time.After() call will be made which which returns a new channel on which a value will only be sent after another 2 seconds. The timeout channel from the previous select execution is discarded and is not used anymore."
"You have to store an mgo.Session, not an mgo.Database instance. And whenever you need to interact with the MongoDB, you acquire a copy or a clone of the session (e.g. with Session.Copy() or Session.Clone()), and you close it when you don't need it (preferable using a defer statement). This will ensure you don't leak connections."
"Here x is not a parameter of the deferred anonymous function, so it will not be evaluated. Only when the anonymous function is executed and it calls fmt.Println()."
"Using a pointer (like &x) pointing to x would work, because only the address is evaluated, and the pointed value at the end will be 5 of course. The problem with this is that fmt.Println() will not print the pointed value but the pointer itself."
"This is similar to the pointer solution, but doesn't need a helper function. But it does need you to write your String() method:"
"When defer statement is executed, only the pointer will be evaluated (address of x, type of *Myint). And since the type *MyInt implements fmt.Stringer, fmt.Println() will call its String() method."
Problem with #2 was that fmt.Println() will print the pointer and not the pointed value (which we solved with our own Print() function). However there are other types which are similar to pointers and fmt.Println() will print their content.
"Reason for seeing 5 is that a slice is a descriptor. When defer is evaluated, a copy is made of the slice (that will be passed to fmt.Println() when it gets executed) but it refers to the same underlying array."
"Also note that fmt.Println() prints the pointed content if the pointer is a pointer to a struct, array, slice, maps, so the following code also works:"
"The datastore knows about the automatically generated intIDs it generates itself, and will never generate the same intID twice (well behavior). However when saving a new entity if you specify an intID yourself, you have to take care about it being unique. This would require to first check if the intID you whish to use is not yet in use (e.g. by querying it first to see if no entity has that intID yet) but even this would not be 100% guarantee that by the time you end up actually saving an entity with this will still be unused. The AllocateIDs() function can be used to obtain a continuous range of intIDs which the datastore will not use to generate intIDs by itself later on, so you are free to use the allocated range of intIDs safely. This also means that if there are concurrent requests also trying to save new entities (either in the same instance or in other instances), they will also never end up using these intIDs if identifier generation is left to the datastore."
"As noted above, intIDs and names are distinct. So AllocateIDs() does not take entities with name identifiers into account just because the name contains a valid number. From the datastore you don't get help to ""allocate"" a name identifier (analog to the AllocateIDs() to allocate intIDs), so it must be application logic to ensure the assigned name is unique else you will end up ""overwriting""/replacing an existing entity."
Finally the documentation of copy() has been updated and it now contains the fact that the minimum length of source and destination will be copied:
"Hiding properties behind getters and setters gives you some extra flexibility to make backwards-compatible changes later. Say you someday want to change Person to store not just a single ""name"" field but first/middle/last/prefix; if you have methods Name() string and SetName(string), you can keep existing users of the Person interface happy while adding new finer-grained methods. Or you might want to be able to mark a database-backed object as ""dirty"" when it has unsaved changes; you can do that when data updates all go through SetFoo() methods. (You could do it other ways, too, like stashing the original data somewhere and comparing when a Save() method is called.)"
"You want to make sure that Begin(), Commit(), and Rollback() appear within the same function. It makes transactions easier to track, and lets you ensure they are closed properly by using a defer."
In my transaction handler I use recover() to catch panics to ensure a Rollback happens right away. I re-throw the panic to allow my code to catch it if a panic is expected. Under normal circumstances a panic should not occur. Errors should be returned instead.
"One thing that may not be immediately clear is that defer can change the return value within a closure if the return variable is captured. In the transaction handler the transaction is committed when err (the return value) is nil. The call to Commit can also return an error, so we set its return to err with err = tx.Commit(). We do not do the same with Rollback because err is non-nil and we do not want to overwrite the existing error."
You have to initalize the global Source used by rand.Intn() and other functions of the rand package using rand.Seed(). For example:
"The issue seems to come from your use of rand.Float64(), which uses a shared global object with a Mutex lock on it."
Calling such a cleanup method is typically done via the defer mechanism which guarantees the method will run no matter if some code which executes after resource acquisition will panic() or not.
"If you're familiar with .NET, it deals with resource cleanup in a way which resembles that of Go quite closely: your objects which wrap some precious resource have to implement the IDisposable interface, and a method, Dispose(), exported by that interface, must be called explicitly when you're done with such an object.  C# provides some syntactic sugar for this use case via the using statement which makes the compiler arrange for calling Dispose() on the object when it goes out of the scope declared by the said statement.  In Go, you'll typically defer calls to cleanup methods."
"A good example is instances of the os.File type representing files on a filesystem.  The fun stuff is that calling Close() on an open file might fail due to legitimate reasons, and if you were writing to that file this might indicate that not all the data you wrote to that file had actually landed in it on the file system.  For an explanation, please read the ""Notes"" section in the close(2) manual."
"So, you can iterate over this slice a and process all parameters, no matter how many there are. A good and popular use-case for variadic arguments is for example fmt.Printf() which takes a format string and a variable number of arguments which will be formatted according to the format string."
"Well as for the implementation, time.Now() falls back to a function implemented in the runtime.
You can review the C time implementation and the implementation for time璺痭ow in assembly (linux amd64 in this case). This then uses clock_gettime, which provides nano seconds resolution.  On windows, this is realized by calling GetSystemTimeAsFileTime, which too generates nanoseconds (not as high res but nanoseconds)."
"Note that reflect.New() will create a new value which is initialized to its zero value (so it will not be a copy of the original). It's not a problem here as Admin only has one field which we're about to change anyway, but must be kept on our mind in general."
"I understand where your are coming from with this. It may be a useful shortcut, but just doesn't make sense. It's kind of like expecting syms.Method() to work when syms's type is []Symbol and Method is for Symbol."
"So if you have the elements as []interface{}, you have to wrap your initial string in a []interface{} to be able to use append():"
"Before we enter into the block, before the t1 := time.Now() line k and v variables are holding the values of the iteration, they are already read out from the map (else they couldn't hold the values). Question: do you think the map is read by the for ... range statement between t1 and t2? Under what circumstances could that happen? We have here a single goroutine that is executing someFunc(). To be able to access the map by the for statement, that would either require another goroutine, or it would require to suspend someFunc(). Obviously neither of those happen. (The for ... range construct is not a multi-goroutine monster.) No matter how many iterations there are, while someFunc() is executed, the map is not accessed by the for statement."
"Note that unlocking in IterateMapKeys() should (must) happen as a deferred statement, as in your original code you may return ""early"" with an error, in which case you didn't unlock, which means the map remained locked! (Here modeled by if someCond {...})."
"Here's an example to make it more concrete: I created a test package http://godoc.org/github.com/dmitris/go-foobar (source in https://github.com/dmitris/go-foobar) - you can see from the documentation page, that the import path is ""github.com/dmitris/go-foobar"" but the package name is foobar, so you would call the function it provides as foobar.Demo() (not go-foobar.Demo()).  "
"In listTest() we build a list with 3 elements, and we store the 2nd element in a global variable e2. Then we remove this element. Now we would expect that except e2 (and the value wrapped in it) everything else gets garbage collected when listTest() returns, because the list is not accessible outside the listTest() function. Yes, we have a pointer in e2 to an element, but e2 has (should have) nothing to do with the list anymore as we removed it."
"If the prev and next pointers in e2 would not be set to nil, values wrapped in elements pointed by them could never be freed, recursively. But since List.Remove() properly sets those to nil, in the above example e1 and e3 閳ユ彸long with the values wrapped in them锟?will be freed (on next garbage collection run)."
"Note that I used runtime.KeepAlive(). This is because after taking the address of arr and getting its length, we don't refer to arr anymore (p being uintptr does not count as a reference), and an aggressive GC might閳ユ悜ightfully閳ユ徍rase arr before we get to the point to print data (pointing to arr). Placing a runtime.KeepAlive() to the end of main() will ensure that arr will not be garbage collected
 before this call. For details, see In Go, when will a variable become unreachable? You do not need to call runtime.KeepAlive() in your code if the supplier of the pointer ensures it will not be garbage collected."
"Basically we only call Module.String() (we only include a dependency) if it is not indirect. As an extra gain, this solution also works on Windows too."
"You can simply use img.At(x, y).RGBA() to get the RBGA values for a pixel, you just need to divide them by 257 to get the 8 bit representation. I'd recommend building your own bi-dimensional array of pixels. Here's a possible implementation, modify it as needed:"
"You can use the reflect.TypeOf() function to obtain a reflect.Type type descriptor. From there, you can list fields of the dynamic value stored in the interface."
"The result of a Type.Field() call is a reflect.StructField value which is a struct, containing the name of the field among other things:"
"If you also want the values of the fields, you may use reflect.ValueOf() to obtain a reflect.Value(), and then you may use Value.Field() or Value.FieldByName():"
"Note: often a pointer to struct is wrapped in an interface. In such cases you may use Type.Elem() and Value.Elem() to ""navigate"" to the pointed type or value:"
"If you don't know whether it's a pointer or not, you can check it with Type.Kind() and Value.Kind(), comparing the result with reflect.Ptr:"
"Also if you need to frequently convert a string to a []byte (e.g. because you need to write it into an io.Writer()), you should consider storing it as a []byte in the first place."
"where the function argument content interface{} is anything that can be marshalled into JSON with json.Marshal(), so in most cases a struct with the proper json tags, or a map[string]interface{}."
"You either use Collection.FindId() and then you pass only the id value, or you use Collection.Find() and then you have to specify a value with the field name too:"
"Summary: For sub-folder packages in an appengine project don't include the ""source repository"" part of the import path OR only use appengine to init() and move all of your other code to separate projects and use like external dependencies. "
"This will force callers to pass at least 1 argument, else it will be a compile-time error. This min() function can be called like this:"
"Converting a string to an interface{} is done in O(1) time. Converting a []string to an interface{} is also done in O(1) time since a slice is still one value. However, converting a []string to an []interface{} is O(n) time because each element of the slice must be converted to an interface{}."
"A tag for a field allows you to attach meta-information to the field which can be acquired using reflection. Usually it is used to provide transformation info on how a struct field is encoded to or decoded from another format (or stored/retrieved from a database), but you can use it to store whatever meta-info you want to, either intended for another package or for your own use."
"We can use reflection (reflect package) to access the tag values of struct fields. Basically we need to acquire the Type of our struct, and then we can query fields e.g. with Type.Field(i int) or Type.FieldByName(name string). These methods return a value of StructField which describes / represents a struct field; and StructField.Tag is a value of type StructTag which describes / represents a tag value."
"Code review guidelines suggest passing small structs like type Point struct { latitude, longitude float64 }, and maybe even things a bit bigger, as values, unless the function you're calling needs to be able to modify them in place."
"For slices you'll reslice (change the start/length/capacity of), built-in functions like append accept a slice value and return a new one. I'd imitate that; it avoids aliasing, returning a new slice helps call attention to the fact that a new array might be allocated, and it's familiar to callers."
"Maps, channels, strings, and function and interface values, like slices, are internally references or structures that contain references already, so if you're just trying to avoid getting the underlying data copied, you don't need to pass pointers to them. (rsc wrote a separate post on how interface values are stored)."
"Consider whether your function should be a method on whichever struct you need a pointer to. People expect a lot of methods on x to modify x, so making the modified struct the receiver may help to minimize surprise. There are guidelines on when receivers should be pointers."
"You mention accepting a pointer to avoid allocations by allowing reuse; changing APIs for the sake of memory reuse is an optimization I'd delay until it's clear the allocations have a nontrivial cost, and then I'd look for a way that doesn't force the trickier API on all users:"
"Broadly, value slices can make sense if either you get all of your items in place up front and don't move them (e.g., no more appends after initial setup), or if you do keep moving them around but you're confident that's OK (no/careful use of pointers to items, and items are small or you've measured the perf impact). Sometimes it comes down to something more specific to your situation, but that's a rough guide."
There is a technical reason. The json library does not have the power to view fields using reflect unless they are exported. A package can only view the unexported fields of types within its own package
"In order to deal with your problem, what you can do is make an unexported type with exported fields. Json will unmarshal into an unexported type if passed to it without a problem but it would not show up in the API docs. You can then make an exported type that embeds the unexported type. This exported type would then need methods to implement the json.Marshaler and json.Unmarshaler interfaces."
"I know. Mind boggling. Also caught me first time.
Go just doesn't use an abstract syntax for datetime components (YYYY-MM-DD), but these exact numbers (I think the time of the first commit of go Nope, according to this. Does anyone know?). "
The problem here is that shower is an interface type. Interface types in Go hold the actual value and its dynamic type. More details about this: The Laws of Reflection #The representation of an interface.
"The slice you return contains 2 non-nil values. The 2nd value is an interface value, a (value;type) pair holding a nil pointer value and a *display concrete type. Quoting from the Go Language Specification: Comparison operators:"
Interfaces unlike other concrete types (non-interfaces) can hold values of different concrete types (different static types). The runtime needs to know the dynamic or runtime-type of the value stored in a variable of interface type.
"An interface is just a method set, any type implements it if the same methods are part of the method set of the type. There are types which cannot be nil, for example a struct or a custom type with int as its underlying type. In these cases you would not need to be able to store a nil value of that specific type."
"But any type also includes concrete types where nil is a valid value (e.g. slices, maps, channels, all pointer types), so in order to store the value at runtime that satisfies the interface it is reasonable to support storing nil inside the interface. But besides the nil inside the interface we must store its dynamic type as the nil value does not carry such information. The alternate option would be to use nil as the interface value itself when the value to be stored in it is nil, but this solution is insufficient as it would lose the dynamic type information."
"Some people say that Go's interfaces are dynamically typed, but that is misleading. They are statically typed: a variable of interface type always has the same static type, and even though at run time the value stored in the interface variable may change type, that value will always satisfy the interface."
"So when you put a *display type into the shower slice, an interface value will be created, which is a pair of (value;type) where value is nil and type is *display. The value inside the pair will be nil, not the interface value itself. If you would put a nil value into the slice, then the interface value itself would be nil and a condition x == nil would be true."
"In case 2 a nil pointer is returned but first it is converted to an interface type (error) so an interface value is created which holds a nil value and the type *MyErr, so the interface value is not nil."
"And if one of them is an error, it's there for a reason (which is the function might fail) and you should not bypass it because if you do, your subsequent code might also fail miserably (e.g. resulting in runtime panic)."
"However there might be situations where you know the code will not fail in any circumstances. In these cases you can provide a helper function (or method) which will discard the error (or raise a runtime panic if it still occurs).
This can be the case if you provide the input values for a function from code, and you know they work.
Great examples of this are the template and regexp packages: if you provide a valid template or regexp at compile time, you can be sure they can always be parsed without errors at runtime. For this reason the template package provides the Must(t *Template, err error) *Template function and the regexp package provides the MustCompile(str string) *Regexp function: they don't return errors because their intended use is where the input is guaranteed to be valid."
"Although using for range the iteration order is ""random"", there are notable exceptions in the standard lib that do process maps in sorted order, namely the encoding/json, text/template, html/template and fmt packages. For more details, see In Golang, why are iterations over maps random?"
"What I would suggest is to not rely on the working directory, but an explicitly specified base path. This may have a default value hard-coded in your application (which may be the working directory as well), and you should provide several ways to override its value."
"Undefined means what it says: undefined. It may be that your program will work correctly, it may be it will work incorrectly. It may result in losing memory and type safety provided by the Go runtime (see example below). It may even crash your program. Or it may even cause the Earth to explode (probability of that is extremely small, maybe even less than 1e-40, but still...)."
"This undefined in your case means that yes, i may be nil, partially assigned, invalid, undefined, ... anything other than either a or b. This list is just a tiny subset of all the possible outcomes."
"Since your code writes to the variable a in one goroutine and reads it in another goroutine (which tries to assign its value to another variable i), it's a data race and as such it's not safe. It doesn't matter if in your tests it works ""correctly"". One could take your code as a starting point, extend / build on it and result in a catastrophe due to your initially ""unharmful"" data race."
"Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. It is reset to 0 whenever the reserved word const appears in the source and increments after each ConstSpec. It can be used to construct a set of related constants:"
"The GOPATH environment variable lists places to look for Go code. On
Unix, the value is a colon-separated string. On Windows, the value is
a semicolon-separated string. On Plan 9, the value is a list."
"The Go binary distributions assume they will be installed in
/usr/local/go (or c:\Go under Windows), but it is possible to install
the Go tools to a different location. In this case you must set the
GOROOT environment variable to point to the directory in which it was
installed."
"goroutine    - stack traces of all current goroutines
  heap         - a sampling of all heap allocations
  threadcreate - stack traces that led to the creation of new OS threads
  block        - stack traces that led to blocking on synchronization primitives  "
"The GOPATH environment variable specifies the location of your workspace. It is likely the only environment variable you'll need to set when developing Go code. To get started, create a workspace directory and set GOPATH accordingly. see: https://golang.org/doc/code.html#GOPATH"
"The packages from the standard library are given short import paths
such as ""fmt"" and ""net/http"". For your own packages, you must choose a
base path that is unlikely to collide with future additions to the
standard library or other external libraries."
"Inside the Test function, the first append reallocates the backing array under the slice variable, copies its original contents over, appends 100 to it, and that's what you're observing.  Upon exiting from Test, the slice variable goes out of scope and so does the (new) underlying array that slice references. (Jeff Lee is correct about that it's not what really happens, so the updated version follows; as he correctly states, this answer is correct, if maybe a bit too terse.)"
"Outside the Test function, a slice of length 7 and capacity 8 is allocated, and its 7 elements filled.
Inside the Test function, the first append sees the that the slice's capacity is still one element larger than its length 锟?in other words, there is room for one more element to add without reallocation.
So it ""eats up"" that remaining element and places 100 to it, after which it adjusts the length in the copy of the slice descriptor to become equal to the slice's capaticy.
This does not affect the slice descriptor's in the caller's scope."
"If you want to make Test behave like append, you have to return the new slice from it 锟?just like append does 锟?and require the callers of Test to use it in the same way they would use append:"
"What you are doing is a fan out pattern, that is to say, multiple endpoints are listening to a single input source. The result of this pattern is, only one of these listeners will be able to get the message whenever there's a message in the input source. The only exception is a close of channel. This close will be recognized by all of the listeners, and thus a ""broadcast""."
"In this case, the solution given above still works. The only difference is, whenever you need a new worker, you need to create a new worker, start it up, and then push it into workers slice. But this method requires a thread-safe slice, which need a lock around it. One of the implementation may look like as follows:"
"One of the good practices is: never leave a dangling goroutine. So when you finished listening, you need to close all of the goroutines you fired. This will be done via quit channel in worker:"
"Since close will be recognized by all listening goroutines (this is the point you understood), all goroutines will be returned. Remember to close your dispatcher routine as well, but I will leave it to you :)"
"There're two high-level pieces to this: figuring out which code goes in which package, and tweaking your APIs to reduce the need for packages to take on as many dependencies. "
"Write config functions for hooking packages up to each other at run time rather than compile time. Instead of routes importing all the packages that define routes, it can export routes.Register, which main (or code in each app) can call. In general, configuration info probably flows through main or a dedicated package; scattering it around too much can make it hard to manage."
"Pass around basic types and interface values. If you're depending on a package for just a type name, maybe you can avoid that. Maybe some code handling a []Page can get instead use a []string of filenames or a []int of IDs or some more general interface (sql.Rows) instead. "
"Consider having 'schema' packages with just pure data types and interfaces, so User is separate from code that might load users from the database. It doesn't have to depend on much (maybe on anything), so you can include it from anywhere. Ben Johnson gave a lightning talk at GopherCon 2016 suggesting that and organizing packages by dependencies."
"As a rule, split a package up when each piece could be useful on its own. If two pieces of functionality are really intimately related, you don't have to split them into packages at all; you can organize with multiple files or types instead. Big packages can be OK; Go's net/http is one, for instance."
"Break up grab-bag packages (utils, tools) by topic or dependency. Otherwise you can end up importing a huge utils package (and taking on all its dependencies) for one or two pieces of functionality (that wouldn't have so many dependencies if separated out)."
"Consider pushing reusable code 'down' into lower-level packages untangled from your particular use case.  If you have a package page containing both logic for your content management system and all-purpose HTML-manipulation code, consider moving the HTML stuff ""down"" to a package html so you can use it without importing unrelated content management stuff. "
"Packages are good for separating independently usable bits of functionality from the caller's perspective. For your internal code organization, you can easily shuffle code between source files in the package. The initial namespace for symbols you define in x/foo.go or x/bar.go is just package x, and it's not that hard to split/join files as needed, especially with the help of a utility like goimports."
"The standard library's net/http is about 7k lines (counting comments/blanks but not tests). Internally, it's split into many smaller files and types. But it's one package, I think 'cause there was no reason users would want, say, just cookie handling on its own. On the other hand, net and net/url are separate because they have uses outside HTTP."
"It's great if you can push ""down"" utilities into libraries that are independent and feel like their own polished products, or cleanly layer your application itself (e.g., UI sits atop an API sits atop some core libraries and data models). Likewise ""horizontal"" separation may help you hold the app in your head (e.g., the UI layer breaks up into user account management, the application core, and administrative tools, or something finer-grained than that). But, the core point is, you're free to split or not as works for you."
"Set up APIs to configure behavior at run-time so you don't have to import it at compile time. So, for example, your URL router can expose a Register method instead of importing appA, appB, etc. and reading a var Routes from each. You could make a myapp/routes package that imports router and all your views and calls router.Register. The fundamental idea is that the router is all-purpose code that needn't import your application's views."
Pass app behavior via interfaces or funcs: http can be passed custom implementations of Handler (of course) but also CookieJar or File. text/template and html/template can accept functions to be accessible from templates (in a FuncMap).
"Export shortcut functions from your package if appropriate: In http, callers can either make and separately configure some http.Server objects, or call http.ListenAndServe(...) that uses a global Server. That gives you a nice design--everything's in an object and callers can create multiple Servers in a process and such--but it also offers a lazy way to configure in the simple single-server case. "
"Separate fundamental tasks from app-dependent ones. One app I work on in another language has a ""utils"" module mixing general tasks (e.g., formatting datetimes or working with HTML) with app-specific stuff (that depends on the user schema, etc.). But the users package imports the utils, creating a cycle. If I were porting to Go, I'd move the user-dependent utils ""up"" out of the utils module, maybe to live with the user code or even above it."
"Consider breaking up grab-bag packages. Slightly enlarging on the last point: if two pieces of functionality are independent (that is, things still work if you move some code to another package) and unrelated from the user's perspective, they're candidates to be separated into two packages. Sometimes the bundling is harmless, but other times it leads to extra dependencies, or a less generic package name would just make clearer code. So my utils above might be broken up by topic or dependency (e.g., strutil, dbutil, etc.). If you wind up with lots of packages this way, we've got goimports to help manage them."
"However, you could change one or both of those return, say, a []uint of IDs or a sql.Rows or some other interface you can get to without importing a specific object type. Depending on your use case, types like User and Group might be so intimately related that it's better just to put them in one package, but if you decide they should be distinct, this is a way. "
"You use the field with the generic type T in a type-switch, and temporarily set the values with concrete types into an interface{}/any. Then type-assert the interface back to T in order to return it. Beware that this assertion is unchecked, so it may panic if for some reason ret holds something that isn't in the type set of T. Of course you can check it with comma-ok but it's still a run-time assertion:"
You can further simplify the code above and get rid of the empty interface. In this case you take the address of the T-type variable and switch on the pointer types. This is fully type-checked at compile time:
"As it works on my machine. However, for the next block you need a pointer to the variables you're assigning the input to. Try replacing fmt.Scanln(text2) with fmt.Scanln(&text2). Don't use Sscanln, because it parses a string already in memory instead of from stdin. If you want to do something like what you were trying to do, replace it with fmt.Scanf(""%s"", &ln)"
"You should not be using the default *http.Client structure in production as this answer originally demonstrated! (Which is what http.Get/etc call to). The reason is that the default client has no timeout set; if the remote server is unresponsive, you're going to have a bad day."
"CanSet returns true if the value of v
can be changed. A Value can be changed
only if it is addressable and was not
obtained by the use of unexported
struct fields. If CanSet returns
false, calling Set or any
type-specific setter (e.g., SetBool,
SetInt64) will panic."
"BTW, Go is available as open source code. A good way to learn about reflection is to see how the core Go developers use it. For example, the Go fmt and json packages. The package documentation has links to the source code files under the heading Package files."
"In short, you can mix and match methods with value receivers and methods with pointer receivers, and use them with variables containing values and pointers, without worrying about which is which. Both will work, and the syntax is the same. However, if methods with pointer receivers are needed to satisfy an interface, then only a pointer will be assignable to the interface 锟?a value won't be valid."
"Closures in Go are lexically scoped. This means that any variables referenced within the closure from the ""outer"" scope are not a copy but are in fact a reference. A for loop actually reuses the same variable multiple times, so you're introducing a race condition between the read/write of the s variable."
"It creates the five go-routines writing to a single channel, each one writing five times. The main go-routine reads all twenty five messages - you may notice that the order they appear in is often not sequential (i.e. the concurrency is evident)."
ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. [...]
"When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(""a/foo"", ""b/foo"") stores ""b/foo"" as the template named ""foo"", while ""a/foo"" is unavailable."
"Then what happens here is that we assigned a new template.Template value to t, which was the result of parsing t2src, so that will be the default, but still both templates can be ""reached"" from it as they are associated. The output changes to this (try it on the Go Playground):"
"Whenever you use a parametrized type, including anywhere a type argument is required, like in the built-in make, you must replace the type parameters in its definition with actual types. This is called instantiation."
On my 64-bit architecture (where the size of int is 8 bytes) it tells that the size of a slice having 2000 elements is roughly 16 KB (in line with 2000 * 8 bytes). A map with 1000 int-int pairs required approximately to allocate 42 KB.
"You're including your time strings in URLs. The + sign is a special character in URL encoding: it denotes the space. So the + gets converted to space (and so it vanishes from your time string). Use proper URL encoding! Check out the net/url package, and this example."
"The sort package contains a function sort(data Interface) that expects any object that implements this interface. Without interfaces, such form of polymorphism would not be possible in go. The fact that you don't have to explicitly annotate that your type implements this interface, is irrelevant."
"Notice treating EOF. Read tries to fill buf on each call, and returns io.EOF as error if it reaches end of file in doing so. In this case buf will still hold data. Consequent calls to Read returns zero as the number of bytes read and same io.EOF as error. Any other error will lead to a panic."
"bufio is just acting as a buffer here, because we don't have much to do with data. In most other situations (specially with text files) bufio is very useful by giving us a nice API for reading and writing easily and flexibly, while it handles buffering behind the scenes."
"The structure suggested in that link in your question is a bit outdated, now with the release of Go 1. You no longer would need to place a pkg directory under src. The only 3 spec-related directories are the 3 in the root of your GOPATH:  bin, pkg, src . Underneath src, you can simply place your project mypack, and underneath that is all of your .go files including the mypack_test.go"
"If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent ""keep-alive"" request."
"Note that the JSON text contains the field names with lowercased text, but the json package is ""clever"" enough to match them. If they would be completely different, you could use struct tags to tell the json package how they are found (or how they should be marshaled) in the JSON text, e.g.:"
"Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an empty slice if s contains only white space."
"Or maybe a better idea would be to make a new type that has []uint8 as its underlying type, make that type a Marshaler, and use that type in your struct."
"Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them. Serve always returns a non-nil error."
"So each incoming HTTP request is handled in its new goroutine, meaning they are served concurrently. Unfortunately the API does not document any way to jump in and change how this works."
For example you could insert a code to each of your http.Handler or handler functions (http.HandlerFunc) which only proceeds if the number of concurrent request serving goroutines are less than a specified limit.
"Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help."
"Yes it is possible. A html.Template is actually a set of template files. If you execute a defined block in this set, it has access to all the other blocks defined in this set."
"To support wrapping, fmt.Errorf now has a %w verb for creating wrapped errors, and three new functions in the errors package ( errors.Unwrap, errors.Is and errors.As) simplify unwrapping and inspecting wrapped errors."
"In contrast, the ServeFile is a lower level helper that can be used to implement something similar to FileServer, or implement your own path munging potentially, and any number of things. It simply takes the named local file and sends it over the HTTP connection. By itself, it won't serve a whole directory prefix (unless you wrote a handler that did some lookup similar to FileServer)"
"NOTE Serving up a filesystem naively is a potentially dangerous thing (there are potentially ways to break out of the rooted tree) hence I recommend that unless you really know what you're doing, use http.FileServer and http.Dir as they include checks to make sure people can't break out of the FS, which ServeFile doesn't."
"Addendum
Your secondary question, how do you do a custom NotFound handler, unfortunately, is not easily answered. Because this is called from internal function serveFile as you noticed, there's no super easy place to break into that. There are potentially some sneaky things like intercepting the response with your own ResponseWriter which intercepts the 404 response code, but I'll leave that exercise to you."
"The default http.Transport is opening and closing connections too quickly. Since all connections are to the same host:port combination, you need to increase MaxIdleConnsPerHost to match your value for num_coroutines. Otherwise, the transport will frequently close the extra connections, only to have them reopened immediately."
"ReadFile reads the file named by filename and returns the contents. A successful call
returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat
an EOF from Read as an error to be reported."
"A simplified io.Writer which only returns an error, but does not report the number of bytes written. If you'd want to provide an implementation which just discards the data (similar to ioutil.Discard), then the implementation does not use (does not need to use) its argument:"
"When you use flate, zlib or gzip to compress the output, you can reduce the output size to about 4.13 bytes/Entry, which is about ~26% of the theoretical size, I'm sure that satisfies you. If not, you can reach out to libs providing compression with higher efficiency like bzip2, which in the above example resulted in 2.04 bytes/Entry, being 12.7% of the theoretical size!"
